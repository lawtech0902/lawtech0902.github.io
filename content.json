{"meta":{"title":"LawTech's Blog","subtitle":"不破不立","description":"破邮python爱好者。","author":"LawTech.","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-03-26T06:40:18.000Z","updated":"2017-03-26T06:40:18.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-26T08:09:29.000Z","updated":"2017-03-26T08:36:08.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About个人简介 lawtech0902— Python爱好者 学生党一枚~ 本科：南邮信息安全 硕士：南邮软件工程 Email：584563542@qq.com 关于这个博客 写着玩儿~ 其他： 皇马球迷，我罗加油；"},{"title":"标签","date":"2017-03-26T05:59:01.000Z","updated":"2017-03-26T06:00:05.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-03-26T05:59:19.000Z","updated":"2017-03-26T06:00:37.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis学习笔记(一)：初识Redis","slug":"Redis-1","date":"2017-03-25T14:21:04.000Z","updated":"2017-03-27T08:40:37.000Z","comments":true,"path":"2017/03/25/Redis-1/","link":"","permalink":"http://yoursite.com/2017/03/25/Redis-1/","excerpt":"","text":"Redis简介Redis是一个速度极快的非关系数据库，也就是我们所说的NoSQL数据库(non-relational database)，它可以存储键(key)与5种不同类型的值(value)之间的映射(mapping)，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展性能，并且它还提供了多种语言的API。 Redis与memcached及其他类型数据库对比Redis经常被拿来与memcached进行比较，两者都可用于存储键值映射，性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，而且Redis除了能存储普通的字符串键，还能存储其他4种数据结构，使得Redis可以用于解决更为广泛的问题，并且即可以作为主数据库使用，又可以作为其他存储系统的辅助数据库。 下表展示了Redis与memcached，MySQL以及MongoDB的特性与功能。 名称 类型 数据存储选项 查询类型 附加功能 Redis 使用内存存储的非关系数据库 字符串、列表、集合、散列表、有序集合 每种数据类型专属的命令，以及批量操作和不完全的事务支持 发布与订阅，主从复制，持久化，脚本 memcached 使用内存存储的键值缓存 键值之间的映射 创建、读取、删除、更新等命令 多线程服务器，用于提升性能 MySQL 关系数据库 每个数据库可以包含多个表，每个表可以包含多个行；可以处理多个表的视图；支持空间和第三方扩展 SELECT、INSERT、UPDATE、DELETE、函数、存储过程 支持ACID性质(需要使用InnoDB)，主从复制，主主复制 MongoDB 使用硬盘存储(on-disk)的非关系文档存储 每个数据库可以包含多个表，每个表可以包含多个无schema的BSON文档 创建、读取、更新、删除、条件查询等命令 支持map-reduce操作，主从复制，分片，空间索引 Redis安装(mac)首先下载用于安装Rudix的引导脚本，并安装Rudix12$ curl -O http://rudix.google.code.com/hg/Ports/rudix/rudix.Py$ sudo python rudix.py install rudix 然后使用命令Rudix安装Redis，若能成功启动Redis服务器则安装成功12$ sudo rudix install redis$ redis-server 最后用pip为Python安装Redis客户端库1$ sudo pip install redis Redis数据结构简介Redis可以存储键与5种不同数据结构类型之间的映射，分别是STRING(字符串)、LIST(列表)、SET(集合)、HASH(散列)、ZSET(有序集合)。有一部分命令对于这5种数据结构是通用的，如DEL、TYPE、RENAME等；但也有一部分命令只能对特定的一种或者两种结构使用。 下表从结构存储的值及读写能力对比了Redis的5种数据结构。 结构类型 结构存储的值 结构的读写能力 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数进行自增或自减操作 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表两端推入或弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或多个元素；根据值查找或移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串互不相同 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有键值对 ZSET 字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素 Redis字符串下表展示了3种简单的字符串命令： 命令 行为 GET 获取存储在给定键中的值 SET 设置存储在给定键中的值 DEL 删除存储在给定键中的值(该命令可用于所有类型) SET、GET、DEL的使用示例：12345678910$ redis-cli127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello\"world\"127.0.0.1:6379&gt; del hello(integer) 1127.0.0.1:6379&gt; get hello(nil)127.0.0.1:6379&gt; SET命令在执行成功时返回OK，Python客户端会将这个OK转换为True；DEL命令在执行成功时将会返回被成功删除的值的数量；GET命令在尝试得到不存在的值时，将会返回一个nil，Python客户端会将这个nil转换为None。 Redis列表下表展示了6种简单的列表命令： 命令 行为 LPUSH(RPUSH) 将给定值推入列表的左端(右端) LPOP(RPOP) 从列表的左端(右端)弹出一个值，并返回被弹出的值 LINDEX 获取列表在给定位置上的单个值 LRANGE 获取列表在给定范围上的所有值 RPUSH、LRANGE、LINDEX、LPOP的使用示例12345678910111213141516171819$ redis-cli127.0.0.1:6379&gt; rpush list-key item(integer) 1127.0.0.1:6379&gt; rpush list-key item2(integer) 2127.0.0.1:6379&gt; rpush list-key item(integer) 3127.0.0.1:6379&gt; lrange list-key 0 -11) \"item\"2) \"item2\"3) \"item\"127.0.0.1:6379&gt; lindex list-key 1\"item2\"127.0.0.1:6379&gt; lpop list-key \"item\"127.0.0.1:6379&gt; lrange list-key 0 -11) \"item2\"2) \"item\"127.0.0.1:6379&gt; RPUSH和LPUSH命令在执行成功后会返回当前列表的长度；列表索引范围从0开始，到-1结束，可以取出列表包含的所有元素；使用LINDEX可以从列表中取出单个元素。 Redis集合Redis的集合和列表都可以存储多个字符串，它们的不同之处在于，列表可以存储多个相同的字符串，而集合则通过散列表来保证自己存储的每个字符串都是不同的(这些散列表只有键)。 下表展示了6种简单的集合命令： 命令 行为 SADD 将给定元素添加到集合 SMEMBERS 返回集合包含的所有元素 SISMEMBER 检查给定元素是否存在于集合中 SREM 如果给定的元素存在于集合中，那么移除这个元素 SADD、SMEMBERS、SISMEMBER、SREM的使用示例12345678910111213141516171819202122232425$ redis-cli127.0.0.1:6379&gt; sadd set-key item(integer) 1127.0.0.1:6379&gt; sadd set-key item2(integer) 1127.0.0.1:6379&gt; sadd set-key item3(integer) 1127.0.0.1:6379&gt; sadd set-key item(integer) 0127.0.0.1:6379&gt; smembers set-key1) \"item2\"2) \"item3\"3) \"item\"127.0.0.1:6379&gt; sismember set-key item4(integer) 0127.0.0.1:6379&gt; sismember set-key item(integer) 1127.0.0.1:6379&gt; srem set-key item2(integer) 1127.0.0.1:6379&gt; srem set-key item2(integer) 0127.0.0.1:6379&gt; smembers set-key1) \"item3\"2) \"item\"127.0.0.1:6379&gt; SADD命令返回1表示成功添加到集合中，返回0表示该元素已存在于集合中；SMEMBERS命令获取到的元素组成的序列将会被Python客户端转换为Python集合；Python客户端会返回一个布尔值来表示SISMEMBER命令的检查结果；SREM命令会返回被移除元素的数量。 Redis散列Redis的散列就像一个微型Redis，它可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串也可以是数值。可以将散列看做文档数据库里面的文档，还可以看做是关系数据库里面的行，因为散列、文档和行都允许用户同时访问或修改一个或多个域(field)。 下表展示了4种简单的列表命令： 命令 行为 HSET 在散列里面关联给定的键值对 HGET 获取指定散列键的值 HGETALL 获取散列包含的所有键值对 HDEL 如果给定键存在于散列里面，那么移除这个键 HSET、HGET、HGETALL、HDEL的使用示例12345678910111213141516171819202122$ redis-cli127.0.0.1:6379&gt; hset hash-key sub-key1 value1(integer) 1127.0.0.1:6379&gt; hset hash-key sub-key2 value2(integer) 1127.0.0.1:6379&gt; hset hash-key sub-key1 value1(integer) 0127.0.0.1:6379&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\"3) \"sub-key2\"4) \"value2\"127.0.0.1:6379&gt; hdel hash-key sub-key2(integer) 1127.0.0.1:6379&gt; hdel hash-key sub-key2(integer) 0127.0.0.1:6379&gt; hget hash-key sub-key1\"value1\"127.0.0.1:6379&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\"127.0.0.1:6379&gt; HSET返回一个值来表示给定的键是否已经存在于散列里面；Python客户端会把HGETALL命令获取的整个散列转换为一个Python字典；HDEL命令执行后会返回一个值来表示给定的键在移除之前是否存在于散列里面。 Redis有序集合有序集合和散列一样，都用于存储键值对：其中有序集合的每个键称为成员（member），都是独一无二的，而有序集合的每个值称为分值（score），都必须是浮点数。有序集合是Redis里面唯一既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。 下表展示了4种简单的有序集合命令： 命令 行为 ZADD 将一个带有给定分值的成员添加到有序集合里面 ZRANGE 根据元素在有序排列中所处的位置，从有序集合里获取多个元素 ZRANGEBYSCORE 获取有序集合在给定分值范围内的所有元素 ZREM 如果给定成员存在于有序集合，那么移除这个成员 ZADD、ZRANGE、ZRANGEBYSCORE、ZREM的使用示例1234567891011121314151617181920212223$ redis-cli127.0.0.1:6379&gt; zadd zset-key 728 member1(integer) 1127.0.0.1:6379&gt; zadd zset-key 982 member0(integer) 1127.0.0.1:6379&gt; zadd zset-key 982 member0(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) \"member1\"2) \"728\"3) \"member0\"4) \"982\"127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores1) \"member1\"2) \"728\"127.0.0.1:6379&gt; zrem zset-key member1(integer) 1127.0.0.1:6379&gt; zrem zset-key member1(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) \"member0\"2) \"982\"127.0.0.1:6379&gt; 在尝试向有序集合添加元素的时候，ZADD命令会返回新添加元素的数量；ZRANGE命令获取有序集合包含的所有元素，这些元素会按照分值进行排序，Python客户端会将这些分值转换成浮点数；ZRANGEBYSCORE命令也可以根据分值来获取有序集合的其中一部分元素；ZREM命令在移除有序集合元素的时候，命令会返回被移除元素的数量。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis, Python","slug":"Redis-Python","permalink":"http://yoursite.com/tags/Redis-Python/"}]},{"title":"Redis学习笔记(二)：Redis命令及其Python API","slug":"Redis-2","date":"2017-03-25T14:21:04.000Z","updated":"2017-03-27T08:40:42.000Z","comments":true,"path":"2017/03/25/Redis-2/","link":"","permalink":"http://yoursite.com/2017/03/25/Redis-2/","excerpt":"","text":"redis-py简介安装在之前的学习笔记(一)中已经安装过redis-py，我的Python版本是3.5.21$ pip3 install redis 快速开始123456&gt;&gt;&gt; import redis&gt;&gt;&gt; r = redis.StrictRedis(host='localhost', port=6379, db=0)&gt;&gt;&gt; r.set('key', 'value')True&gt;&gt;&gt; r.get('key')b'value' API参考Redis的官方命令文档很好地解释了每个命令的详细信息。 redis-py公开了实现这些命令的两个客户端类。 第一，StrictRedis类试图遵守官方命令语法， 但是有些一些例外： SELECT: 没有实现，考虑到线程安全的原因。 DEL: 由于del是python语法关键字，所用delete来代替。 CONFIG GET|SET: 分开用 config_get or config_set来代替 MULTI/EXEC: 事务作为Pipeline类的其中一部分的实现。Pipeline默认保证了MULTI,EXEC声明。但是你可以指定transaction=False来禁用这一行为。 SUBSCRIBE/LISTEN:PubSub作为一个独立的类来实现发布订阅机制。 SCAN/SSCAN/HSCAN/ZSCAN:每个命令都对应一个等价的迭代器方法scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior。 第二，Redis类是StrictRedis的子类，提供redis-py版本向后的兼容性。 关于StrictRedis与Redis的区别：(官方推荐使用StrictRedis.) 以下几个方法在StrictRedis和Redis类中的参数顺序不同。 LREM: 在Redis类中是这样的：lrem(self, name, value, num=0)在StrictRedis类中是这样的：lrem(self, name, count, value) ZADD: 在Redis类中是这样的：zadd(‘my-key’, ‘name1’, 1.1, ‘name2’, 2.2, name3=3.3, name4=4.4)在StrictRedis中是这样的：zadd(‘my-key’, 1.1, ‘name1’, 2.2, ‘name2’, name3=3.3, name4=4.4) SETEX: 在Redis类中是这样的：setex(self, name, value, time)而在StrictRedis中是这样的：setex(self, name, time, value) 连接池 redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认情况下，每个Redis实例都会依次创建并维护一个自己的连接池。我们可以直接建立一个连接池，然后传递给Redis或StrictRedis连接命令作为参数，这样就可以实现多个Redis实例共享一个连接池，以实现客户端分片，或者对连接的管理方式进行更高精度的控制。 12&gt;&gt;&gt; pool = redis.ConnectionPool(host='localhost', port=6379, db=0)&gt;&gt;&gt; r = redis.StrictRedis(connection_pool=pool) 我们也可以创建自己的Connection子类，用于控制异步框架中的套接字行为，要使用自己的连接实例化客户端类，需要创建一个连接池，将类传递给connection_class参数。 1&gt;&gt;&gt; pool = redis.ConnectionPool(connection_class=YourConnectionClass,your_arg='...', ...) 释放连接回到连接池：可以使用Redis类的reset()方法，或者使用with上下文管理语法。 解析器：解析器控制如何解析Redis-server的响应内容，redis-py提供两种方式的解析器类支持PythonParser和HiredisParser(需要单独安装)。它优先选用HiredisParser,如果不存在，则选用PythonParser. Hiredis是redis核心团队开发的一个高性能c库，能够提高10x的解析速度。 响应回调：The client class使用一系列的callbacks来完成响应到对应python类型的映射。这些响应回调，定义在 Redis client class中的RESPONSE_CALLBACKS字典中。你可以使用set_response_callback 方法来添加自定义回调类。这个方法接受两个参数：一个命令名字，一个回调类。回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数。 线程安全性Redis客户端实例可以安全地在线程之间共享。 在内部，连接实例只在命令执行期间从连接池检索，并在执行后直接返回到池中。 命令执行过程从不修改客户端实例上的状态。 但是，有一个警告：Redis SELECT命令。 SELECT命令允许您切换连接正在使用的数据库。 该数据库保持选中，直到选择另一个或连接关闭为止。 这会创建一个问题，因为可以将连接返回到连接到不同数据库的池。 因此，redis-py不会在客户端实例上实现SELECT命令。 如果在同一应用程序中使用多个Redis数据库，则应为每个数据库创建一个单独的客户机实例（也可能是单独的连接池）。 在线程之间传递PubSub或Pipeline对象是不安全的。 Redis命令及其对应redis-py API由于Redis官方命令文档很好地解释了每个命令的详细信息，所以我这里只对最常用的Redis命令进行整理，并给出其redis-py API。 字符串下表展示了对Redis字符串执行自增和自减操作的命令及其redis-py API。 命令 用例 描述 redis-py API INCR INCR key-name 将键存储的值加1 incr(name, amount=1) DECR DECR key-name 将键存储的值减1 decr(name, amount=1) INCRBY INCRBY key-name amount 将键存储的值加整数amount incr(name, amount=1) DECRBY DECRBY key-name amount 将键存储的值减整数amount decr(name, amount=1) INCRBYFLOAT INCRBYFLOAT key-name amount 将键存储的值加浮点数amount incrbyfloat(name, amount=1.0) 在redis-py内部，使用了INCRBY和DECRBY命令来实现incr()和decr()方法，并且第二个参数amount是可选的，默认为1。 下面这个交互示例展示了Redis的INCR和DECR操作12345678910111213&gt;&gt;&gt; r.get('key')&gt;&gt;&gt; r.incr('key')1&gt;&gt;&gt; r.incr('key', 15)16&gt;&gt;&gt; r.get('key')b'16'&gt;&gt;&gt; r.decr('key', 5)11&gt;&gt;&gt; r.set('key', 13)True&gt;&gt;&gt; r.incr('key')14 当用户将一个值存储到Redis字符串中时，如果这个值可以被解释(interpet)为十进制整数或者浮点数，那么Redis会允许用户对这个字符串执行各种INCR和DECR操作。如果用户对一个不存在的键或者一个保存了空串的键执行自增或自减操作，Redis会自动将这个键的值当作是0来处理。若非上述情况，则Redis将会返回一个错误。 除了自增和自减操作，Redis还可以对字节串进行读取和写入的操作。 下表展示了Redis用来处理字符串子串和二进制位的命令及其redis-py API。 命令 用例 描述 redis-py API APPEND APPEND key-name value 将值value追加到给定键key-name当前存储的值的末尾 append(key, value) GETRANGE GETRANGE key-name start end 获取一个偏移量从start到end的子串，包含start和end getrange(key, start, end) SETRANGE SETRANGE key-name offset value 将从start开始的子串设置为给定值 setrange(name, offset, value) GETBIT GETBIT key-name offset 将字节串看作是二进制位串，并返回位串中偏移量为offset的二进制位的值 getbit(name, offset) SETBIT SETBIT key-name offset value 将字节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设为value setbit(name, offset, value) BITCOUNT BITCOUNT key-name [start end] 统计字符串被设置为1的bit数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行 bitcount(key, start=None, end=None) BITOP BITOP operation dest-key key-name [key-name …] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 bitop(operation, dest, *keys) 在执行如果offset比当前key对应string还要长，那这个string后面就补0以达到offset不存在的keys被认为是空字符串","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis, Python","slug":"Redis-Python","permalink":"http://yoursite.com/tags/Redis-Python/"}]}]}