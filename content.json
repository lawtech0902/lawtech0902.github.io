{"meta":{"title":"LawTech's Blog","subtitle":"不破不立","description":"破邮python爱好者。","author":"LawTech.","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-03-26T06:40:18.000Z","updated":"2017-03-26T06:40:18.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2017-03-26T05:59:19.000Z","updated":"2017-03-26T06:00:37.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-26T08:09:29.000Z","updated":"2017-03-26T08:36:08.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About个人简介 lawtech0902— Python爱好者 学生党一枚~ 本科：南邮信息安全 硕士：南邮软件工程 Email：584563542@qq.com 关于这个博客 写着玩儿~ 其他： 皇马球迷，我罗加油；"},{"title":"标签","date":"2017-03-26T05:59:01.000Z","updated":"2017-03-26T06:00:05.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis学习笔记(三)：Redis命令补充","slug":"Redis-3","date":"2017-04-06T12:18:54.000Z","updated":"2017-04-06T13:07:11.000Z","comments":true,"path":"2017/04/06/Redis-3/","link":"","permalink":"http://yoursite.com/2017/04/06/Redis-3/","excerpt":"在之前的学习笔记中，还有许多Redis的命令没有涉及，这一篇主要用来简要地补充，当然，详细的命令还得参考Redis的官方命令文档。","text":"在之前的学习笔记中，还有许多Redis的命令没有涉及，这一篇主要用来简要地补充，当然，详细的命令还得参考Redis的官方命令文档。 键值相关命令下表展示了Redis提供的一些键值(KEY-VALUE)相关的常用命令及其redis-py API 命令 用例 描述 redis-py API KEYS KEYS pattern 查找所有符合给定模式pattern(正则表达式)的key keys(pattern=’*’) EXISTS EXISTS key 检查给定key是否存在 exists(name) EXPIRE EXPIRE key seconds 为给定key设置生存时间，当key过期时(生存时间为0)，它会被自动删除 expire(name, time) MOVE MOVE key db 将当前数据库的key移动到给定的数据库db当中 move(name, db) PERSIST PERSIST key 移除给定key的生存时间，将这个key从『易失的』(带生存时间key)转换成『持久的』(一个不带生存时间、永不过期的key) persist(name) RANDOMKEY RANDOMKEY 从当前数据库返回一个随机的key randomkey() RENAME RENAME key newkey 将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖 rename(src, dst) TYPE TYPE key 返回key所存储的value的数据结构类型，它可以返回string, list, set, zset和hash等不同的类型 type(name) TTL TTL key 返回key剩余的过期时间(单位：秒) ttl(name) 下面这个交互示例展示了Redis中关于键的过期时间相关的命令的使用方法 12345678910111213&gt;&gt;&gt; r.set('key', 'value')True&gt;&gt;&gt; r.get('key')b'value'&gt;&gt;&gt; r.expire('key', 2)True&gt;&gt;&gt; time.sleep(2)&gt;&gt;&gt; r.get('key')&gt;&gt;&gt; r.set('key', 'value2')True&gt;&gt;&gt; r.expire('key', 100); r.ttl('key')True100 发布与订阅发布订阅(pub/sub)是一种消息通信模式，主要的目的是解耦消息发布者和消息订阅者之间的耦合，这点和设计模式中的观察者模式比较相似。pub/sub不仅仅解决发布者和订阅者之间代码级别耦合也解决两者在物理部署上的耦合。Redis作为一个pub/sub的server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向 redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道(channel)。当发布者通过publish命令向 redis server发送二进制字符串消息(binary string message)时，订阅该消息类型的全部client都会收到此消息。这里消息的传递是多对多的，一个client可以订阅多个channel，也可以向多个channel发送消息。 下表展示了Redis提供的发布与订阅命令及其redis-py API 命令 用例 描述 redis-py API SUBSCRIBE SUBSCRIBE channel [channel …] 订阅给定的频道 subscribe(args, *kwargs) UNSUBSCRIBE UNSUBSCRIBE [channel [channel …]] 退订给定的频道，如果没有给定任何频道，则退订所有频道 unsubscribe(*args) PUBLISH PUBLISH channel message 将信息message发送到指定的频道channel publish(channel, message) PSUBSCRIBE PSUBSCRIBE pattern [pattern …] 订阅与给定模式相关的频道 psubscribe(args, *kwargs) PUNSUBSCRIBE PUNSUBSCRIBE [pattern [pattern …]] 退订给定的模式，如果没有给定，则退订所有模式 PUNSUBSCRIBE [pattern [pattern …]] PUBSUB PUBSUB subcommand [argument [argument …]] PUBSUB命令是一个introspection命令，允许检查Pub/Sub子系统的状态，它由单独记录的子命令组成 pubsub(**kwargs) 考虑到PUBLISH命令和SUBSCRIBE命令在Python客户端的实现方式，一个比较简单的延时发布与订阅的方法，就是像如下代码那样用辅助线程(helper thread)来执行PUBLISH命令 1234567891011121314151617181920212223242526import redisimport timeimport threadingpool = redis.ConnectionPool(host='localhost', port=6379, db=0)r = redis.StrictRedis(connection_pool=pool)def publisher(n): time.sleep(1) for i in range(n): r.publish('channel', i)def run_pubsub(): threading.Thread(target=publisher, args=(3,)).start() pubsub = r.pubsub() pubsub.subscribe(['channel']) count=0 for item in pubsub.listen(): print(item) count += 1 if count == 4: pubsub.unsubscribe() if count == 5: break publisher函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。在发布消息之后进行短暂的休眠，让消息可以一条接一条地出现。 run_pubsub函数启动发送者线程，让它发送三条消息。随后创建发布与订阅对象，并让它订阅给定的频道。通过遍历函数pubsub.listen()的执行结果来监听订阅消息。在接收到一条订阅反馈消息和三条发布者发送的消息之后，执行退订操作，停止监听新消息。客户端在接收到退订反馈消息之后，就不再接收消息。 实际运行函数并观察它们的行为123456&gt;&gt;&gt; run_pubsub()&#123;'type': 'subscribe', 'channel': b'channel', 'data': 1, 'pattern': None&#125;&#123;'type': 'message', 'channel': b'channel', 'data': b'0', 'pattern': None&#125;&#123;'type': 'message', 'channel': b'channel', 'data': b'1', 'pattern': None&#125;&#123;'type': 'message', 'channel': b'channel', 'data': b'2', 'pattern': None&#125;&#123;'type': 'unsubscribe', 'channel': b'channel', 'data': 0, 'pattern': None&#125; 以上这些结构就是我们在遍历pubsub.listen()函数时得到的元素。 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。在退订频道时，客户端会接收到一条反馈消息，告知被退订的是哪一个频道，以及客户端目前仍在订阅的频道数量。 其他命令排序Redis中负责执行排序操作的SORT命令可以根据字符串、列表、集合、有序集合、散列这5中键里面存储的数据，对列表、集合以及有序集合进行排序，可以将SORT命令看作是SQL语言中的order by子句。 下表展示了SORT命令的定义及其redis-py API 命令 用例 描述 redis-py API SORT SORT key [BY pattern] [LIMIT offset count] [GET pattern] [ASC\\ DESC] [ALPHA] destination 返回或存储key的list、set或sorted set中的元素。默认是按照数值类型排序的，并且按照两个元素的双精度浮点数类型值进行比较 sort(name, start=None, num=None, by=None, get=None, desc=False, alpha=False, store=None, groups=False) 下面展示了SORT命令的一些简单的用法123456789101112131415161718&gt;&gt;&gt; r.rpush('sort-input', 23, 15, 110, 7)4&gt;&gt;&gt; r.sort('sort-input')[b'7', b'15', b'23', b'110']&gt;&gt;&gt; r.sort('sort-input', alpha=True)[b'110', b'15', b'23', b'7']&gt;&gt;&gt; r.hset('d-7', 'field', 5)1&gt;&gt;&gt; r.hset('d-15', 'field', 1)1&gt;&gt;&gt; r.hset('d-23', 'field', 9)1&gt;&gt;&gt; r.hset('d-110', 'field', 3)1&gt;&gt;&gt; r.sort('sort-input', by='d-*-&gt;field')[b'15', b'110', b'7', b'23']&gt;&gt;&gt; r.sort('sort-input', by='d-*-&gt;field', get='d-*-&gt;field')[b'1', b'3', b'5', b'9'] SORT命令不仅可以对列表进行排序，还可以对集合进行排序，然后返回一个列表形式的排序结果。上述代码除了展示如何使用alpha关键字(根据元素字母表顺序，默认根据大小)参数对元素进行字符串排序之外，还展示了如何基于外部数据对元素进行排序，以及如何获取并返回外部数据。 尽管SORT是Redis中唯一一个可以同时处理3种不同类型的数据的命令，但是事务同样可以让我们在一连串不间断执行的命令里面操作不同类型的数据。 基本的Redis事务Redis中的事务(transaction)是一组命令的集合。MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。 事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部执行，要么全不执行。 事务的应用非常普遍，比如银行汇款过程中A向B汇款，系统先从A的账户中将钱划走，然后向B的账户中增加相应的金额。这两个步骤必须属于同一个事务，要么全部执行，要么全不执行。 Redis的基本事务(basic transaction)需要用到MULTI和EXEC命令。在Redis中，被MULTI和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕后，才会处理其他客户端的命令。 Redis中执行事务的步骤：首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，最后再执行EXEC命令。MULTI命令用于开启一个事务，它总是返回OK 。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。另一方面，通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务。EXEC命令的回复是一个数组，数组中的每个元素都是执行事务中的命令所产生的回复。其中，回复元素的先后顺序和命令发送的先后顺序一致。当客户端处于事务状态时，所有传入的命令都会返回一个内容为QUEUED的状态回复status reply，这些被入队的命令将在EXEC命令被调用时执行。 从语义上来说，Redis事务在Python客户端中是由管道(pipeline)实现的：对连接对象调用pipeline()方法将创建一个事务，在一切正常的情况下，客户端会自动地调用MULTI命令包裹用户输入的多个命令。此外，为了减少Redis与客户端之间的通信往返次数，提升执行多个命令的性能，Python的Redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令都发送给Redis。 要展示事务执行的结果，最简单的方法就是将事务放到线程里面执行，下面这个交互示例展示了在没有使用事务的情况下，执行并行(parallel)自增操作的结果1234567891011121314151617&gt;&gt;&gt; import redis&gt;&gt;&gt; import threading&gt;&gt;&gt; import time&gt;&gt;&gt; r = redis.StrictRedis(host='localhost', port=6379, db=0)&gt;&gt;&gt; def notrans():... print(r.incr('notrans:'))... time.sleep(.1)... r.incr('notrans:', -1)...&gt;&gt;&gt; if 1:... for i in range(3):... threading.Thread(target=notrans).start()... time.sleep(.5)...213 上述代码启动了3个线程来执行没有被事务包裹的自增、休眠和自减操作，正因为没有使用事务，所以三个线程都可以在执行自减操作前，对notrans:计数器执行自增操作。 下面这个交互示例就展示了如何使用事务处理命令的并行执行问题 123456789101112131415&gt;&gt;&gt; def trans():... pipeline = r.pipeline()... pipeline.incr('trans:')... time.sleep(.1)... pipeline.incr('trans:', -1)... print(pipeline.execute()[0])...&gt;&gt;&gt; if 1:... for i in range(3):... threading.Thread(target=trans).start()... time.sleep(.5)...111 首先在trans函数中创建一个事务型(transactional)管道对象，然后先把针对’tans:’计数器的自增操作放入队列，等待100ms后再将针对’tans:’计数器的自减操作放入队列，最后执行被事务包裹的命令，并打印自增操作的执行结果。最终在执行结果中可以看到，尽管自增和自减操作之间有一段延迟时间，但通过使用事务，各个线程都可以在不被其他线程打断的情况下，执行各自队列里面的命令。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis, Python","slug":"Redis-Python","permalink":"http://yoursite.com/tags/Redis-Python/"}]},{"title":"Redis学习笔记(二)：Redis命令及其Python API","slug":"Redis-2","date":"2017-03-27T08:18:54.000Z","updated":"2017-03-30T12:17:22.000Z","comments":true,"path":"2017/03/27/Redis-2/","link":"","permalink":"http://yoursite.com/2017/03/27/Redis-2/","excerpt":"redis-py简介安装在之前的学习笔记(一)中已经安装过redis-py，我的Python版本是3.5.2","text":"redis-py简介安装在之前的学习笔记(一)中已经安装过redis-py，我的Python版本是3.5.21$ pip3 install redis 快速开始123456&gt;&gt;&gt; import redis&gt;&gt;&gt; r = redis.StrictRedis(host='localhost', port=6379, db=0)&gt;&gt;&gt; r.set('key', 'value')True&gt;&gt;&gt; r.get('key')b'value' API参考Redis的官方命令文档很好地解释了每个命令的详细信息。 redis-py公开了实现这些命令的两个客户端类。 第一，StrictRedis类试图遵守官方命令语法， 但是有些一些例外： SELECT: 没有实现，考虑到线程安全的原因。 DEL: 由于del是python语法关键字，所用delete来代替。 CONFIG GET|SET: 分开用 config_get or config_set来代替 MULTI/EXEC: 事务作为Pipeline类的其中一部分的实现。Pipeline默认保证了MULTI,EXEC声明。但是你可以指定transaction=False来禁用这一行为。 SUBSCRIBE/LISTEN:PubSub作为一个独立的类来实现发布订阅机制。 SCAN/SSCAN/HSCAN/ZSCAN:每个命令都对应一个等价的迭代器方法scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior。 第二，Redis类是StrictRedis的子类，提供redis-py版本向后的兼容性。 关于StrictRedis与Redis的区别：(官方推荐使用StrictRedis.) 以下几个方法在StrictRedis和Redis类中的参数顺序不同。 LREM: 在Redis类中是这样的：lrem(self, name, value, num=0)在StrictRedis类中是这样的：lrem(self, name, count, value) ZADD: 在Redis类中是这样的：zadd(‘my-key’, ‘name1’, 1.1, ‘name2’, 2.2, name3=3.3, name4=4.4)在StrictRedis中是这样的：zadd(‘my-key’, 1.1, ‘name1’, 2.2, ‘name2’, name3=3.3, name4=4.4) SETEX: 在Redis类中是这样的：setex(self, name, value, time)而在StrictRedis中是这样的：setex(self, name, time, value) 连接池 redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认情况下，每个Redis实例都会依次创建并维护一个自己的连接池。我们可以直接建立一个连接池，然后传递给Redis或StrictRedis连接命令作为参数，这样就可以实现多个Redis实例共享一个连接池，以实现客户端分片，或者对连接的管理方式进行更高精度的控制。 12&gt;&gt;&gt; pool = redis.ConnectionPool(host='localhost', port=6379, db=0)&gt;&gt;&gt; r = redis.StrictRedis(connection_pool=pool) 我们也可以创建自己的Connection子类，用于控制异步框架中的套接字行为，要使用自己的连接实例化客户端类，需要创建一个连接池，将类传递给connection_class参数。 1&gt;&gt;&gt; pool = redis.ConnectionPool(connection_class=YourConnectionClass,your_arg='...', ...) 释放连接回到连接池：可以使用Redis类的reset()方法，或者使用with上下文管理语法。 解析器：解析器控制如何解析Redis-server的响应内容，redis-py提供两种方式的解析器类支持PythonParser和HiredisParser(需要单独安装)。它优先选用HiredisParser,如果不存在，则选用PythonParser. Hiredis是redis核心团队开发的一个高性能c库，能够提高10x的解析速度。 响应回调：The client class使用一系列的callbacks来完成响应到对应python类型的映射。这些响应回调，定义在 Redis client class中的RESPONSE_CALLBACKS字典中。你可以使用set_response_callback 方法来添加自定义回调类。这个方法接受两个参数：一个命令名字，一个回调类。回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数。 线程安全性Redis客户端实例可以安全地在线程之间共享。 在内部，连接实例只在命令执行期间从连接池检索，并在执行后直接返回到池中。 命令执行过程从不修改客户端实例上的状态。 但是，有一个警告：Redis SELECT命令。 SELECT命令允许您切换连接正在使用的数据库。 该数据库保持选中，直到选择另一个或连接关闭为止。 这会创建一个问题，因为可以将连接返回到连接到不同数据库的池。 因此，redis-py不会在客户端实例上实现SELECT命令。 如果在同一应用程序中使用多个Redis数据库，则应为每个数据库创建一个单独的客户机实例（也可能是单独的连接池）。 在线程之间传递PubSub或Pipeline对象是不安全的。 Redis命令及其对应redis-py API由于Redis官方命令文档很好地解释了每个命令的详细信息，所以我这里只对最常用的Redis命令进行整理，并给出其redis-py API。 字符串下表展示了对Redis字符串执行自增和自减操作的命令及其redis-py API。 命令 用例 描述 redis-py API INCR INCR key-name 将键存储的值加1 incr(name, amount=1) DECR DECR key-name 将键存储的值减1 decr(name, amount=1) INCRBY INCRBY key-name amount 将键存储的值加整数amount incr(name, amount=1) DECRBY DECRBY key-name amount 将键存储的值减整数amount decr(name, amount=1) INCRBYFLOAT INCRBYFLOAT key-name amount 将键存储的值加浮点数amount incrbyfloat(name, amount=1.0) 在redis-py内部，使用了INCRBY和DECRBY命令来实现incr()和decr()方法，并且第二个参数amount是可选的，默认为1。 下面这个交互示例展示了Redis的INCR和DECR操作12345678910111213&gt;&gt;&gt; r.get('key')&gt;&gt;&gt; r.incr('key')1&gt;&gt;&gt; r.incr('key', 15)16&gt;&gt;&gt; r.get('key')b'16'&gt;&gt;&gt; r.decr('key', 5)11&gt;&gt;&gt; r.set('key', 13)True&gt;&gt;&gt; r.incr('key')14 当用户将一个值存储到Redis字符串中时，如果这个值可以被解释(interpet)为十进制整数或者浮点数，那么Redis会允许用户对这个字符串执行各种INCR和DECR操作。如果用户对一个不存在的键或者一个保存了空串的键执行自增或自减操作，Redis会自动将这个键的值当作是0来处理。若非上述情况，则Redis将会返回一个错误。 除了自增和自减操作，Redis还可以对字节串进行读取和写入的操作。 下表展示了Redis用来处理字符串子串和二进制位的命令及其redis-py API。 命令 用例 描述 redis-py API APPEND APPEND key-name value 将值value追加到给定键key-name当前存储的值的末尾 append(key, value) GETRANGE GETRANGE key-name start end 获取一个偏移量从start到end的子串，包含start和end getrange(key, start, end) SETRANGE SETRANGE key-name offset value 将从start开始的子串设置为给定值 setrange(name, offset, value) GETBIT GETBIT key-name offset 将字节串看作是二进制位串，并返回位串中偏移量为offset的二进制位的值 getbit(name, offset) SETBIT SETBIT key-name offset value 将字节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设为value setbit(name, offset, value) BITCOUNT BITCOUNT key-name [start end] 统计字符串被设置为1的bit数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行 bitcount(key, start=None, end=None) BITOP BITOP operation dest-key key-name [key-name …] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 bitop(operation, dest, *keys) 在执行SETRANGE或者SETBIT命令时，如果offset比当前key对应string还要长，那这个string后面就补空字节(null)以达到offset。使用GETRANGE时超出字符串末尾的数据会被认为是空字符串，而使用GETBIT时超出字符串末尾的二进制位会被视为是0。 下面这个交互示例展示了Redis的子串操作和二进制位操作123456789101112131415161718192021222324&gt;&gt;&gt; r.append('new-string-key', 'hello ')6&gt;&gt;&gt; r.append('new-string-key', 'world!')12&gt;&gt;&gt; r.substr('new-string-key', 3, 7)b'lo wo'&gt;&gt;&gt; r.getrange('new-string-key', 3, 7)b'lo wo'&gt;&gt;&gt; r.setrange('new-string-key', 0, 'H')12&gt;&gt;&gt; r.get('new-string-key')b'Hello world!'&gt;&gt;&gt; r.setrange('new-string-key', 11, ', how are you?')25&gt;&gt;&gt; r.get('new-string-key')b'Hello world, how are you?'&gt;&gt;&gt; r.setbit('another-key', 2, 1)0&gt;&gt;&gt; r.setbit('another-key', 7, 1)0&gt;&gt;&gt; r.getbit('another-key', 1)0&gt;&gt;&gt; r.get('another-key')b'!' Redis现在的GETRANGE命令是由以前的SUBSTR命令改名而来，所以现在redis-py中两者仍然都可以使用，但是最好还是使用getrange()方法来获取子串。 列表下表展示了一些之前介绍过的常用列表命令 命令 用例 描述 redis-py API RPUSH RPUSH key value [value …] 向存于key的列表的尾部插入所有指定的值 rpush(name, *values) LPUSH LPUSH key value [value …] 将所有指定的值插入到存于key的列表的头部 lpush(name, *values) RPOP RPOP key 移除并返回key对应的list的最后一个元素 rpop(name) LPOP LPOP key 移除并返回key对应的list的第一个元素 lpop(name) LINDEX LINDEX key index 返回列表索引位置的元素 lindex(name, index) LRANGE LRANGE key start stop 返回存储在key的列表里指定范围内的元素 lrange(name, start, end) LTRIM LTRIM key start stop 修剪(trim)一个已存在的list，这样list就会只包含指定范围的指定元素 ltrim(name, start, end) 下面这个交互示例展示了Redis列表的推入和弹出操作12345678910111213141516171819202122&gt;&gt;&gt; r.rpush('list-key', 'last')1&gt;&gt;&gt; r.lpush('list-key', 'first')2&gt;&gt;&gt; r.rpush('list-key', 'new last')3&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'first', b'last', b'new last']&gt;&gt;&gt; r.lpop('list-key')b'first'&gt;&gt;&gt; r.lpop('list-key')b'last'&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'new last']&gt;&gt;&gt; r.rpush('list-key', 'a', 'b', 'c')4&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'new last', b'a', b'b', b'c']&gt;&gt;&gt; r.ltrim('list-key', 2, -1)True&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'b', b'c'] 还有几个列表命令能将元素从一个列表移动到另一个列表，或者阻塞(block)执行命令的客户端直到有其他客户端给列表添加元素为止。 下表列出了这些阻塞弹出命令以及列表之间移动元素的命令 命令 用例 描述 redis-py API BLPOP BLPOP key [key …] timeout 弹出第一个非空列表的头元素，或在timeout秒内阻塞并等待可弹出的元素出现 blpop(keys, timeout=0) BRPOP BRPOP key [key …] timeout 弹出第一个非空列表的末尾元素，或在timeout秒内阻塞并等待可弹出的元素出现 brpop(keys, timeout=0) RPOPLPUSH RPOPLPUSH source destination 原子性地返回并移除存储在source的列表的最后一个元素(列表尾部元素)， 并把该元素放入存储在destination的列表的第一个元素位置(列表头部) rpoplpush(src, dst) BRPOPLPUSH BRPOPLPUSH source destination timeout BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 brpoplpush(src, dst, timeout=0) 注：原子性是指命令正在都区或者修改数据的时候，其他客户端不能读取或修改相同的数据。 下面这个交互示例展示了Redis列表的阻塞弹出命令以及元素移动命令1234567891011121314151617181920&gt;&gt;&gt; r.rpush('list', 'item1')1&gt;&gt;&gt; r.rpush('list', 'item2')2&gt;&gt;&gt; r.rpush('list2', 'item3')1&gt;&gt;&gt; r.brpoplpush('list2', 'list', 1)b'item3'&gt;&gt;&gt; r.brpoplpush('list2', 'list', 1)&gt;&gt;&gt; r.lrange('list', 0, -1)[b'item3', b'item1', b'item2']&gt;&gt;&gt; r.brpoplpush('list', 'list2', 1)b'item2'&gt;&gt;&gt; r.blpop(['list', 'list2'], 1)(b'list', b'item3')&gt;&gt;&gt; r.blpop(['list', 'list2'], 1)(b'list', b'item1')&gt;&gt;&gt; r.blpop(['list', 'list2'], 1)(b'list2', b'item2')&gt;&gt;&gt; r.blpop(['list', 'list2'], 1) 对于阻塞弹出命令和弹出并推入命令，最常见的用例就是消息传递(messaging)和任务队列(task queue)。 集合下表展示了一部分最常用的集合命令 命令 用例 描述 redis-py API SADD SADD key member [member …] 添加一个或多个指定的member元素到key集合中 sadd(name, *values) SREM SREM key member [member …] 在key集合中移除指定的元素 srem(name, *values) SISMEMBER SISMEMBER key member 返回成员member是否是存储的集合key的成员 sismember(name, value) SCARD SCARD key 返回集合包含元素的数量 scard(name) SMEMBERS SMEMBERS key 返回key集合所有的元素 smembers(name) SRANDMEMBER SRANDMEMBER key [count] 仅提供key参数,那么随机返回key集合中的一个元素，返回含有 count 个不同的元素的数组，对count分情况处理 srandmember(name, number=None) SPOP SPOP key [count] 从key对应集合中返回并删除一个或多个元素 spop(name) SMOVE SMOVE source destination member 将member从source集合移动到destination集合中 smove(src, dst, value) 下面这个交互示例展示了这些常用的集合命令12345678910111213141516&gt;&gt;&gt; r.sadd('set-key', 'a', 'b', 'c')3&gt;&gt;&gt; r.srem('set-key', 'c', 'd')1&gt;&gt;&gt; r.srem('set-key', 'c', 'd')0&gt;&gt;&gt; r.scard('set-key')2&gt;&gt;&gt; r.smembers('set-key')&#123;b'b', b'a'&#125;&gt;&gt;&gt; r.smove('set-key', 'set-key2', 'a')True&gt;&gt;&gt; r.smove('set-key', 'set-key2', 'c')False&gt;&gt;&gt; r.smembers('set-key2')&#123;b'a'&#125; 但是集合真正厉害的地方在于组合和关联多个集合，下表展示了相关的Redis命令 命令 用例 描述 redis-py API SDIFF SDIFF key [key …] 返回一个集合与给定集合的差集的元素 sdiff(keys, *args) SDIFFSTORE SDIFFSTORE destination key [key …] 类似于 SDIFF，不同之处在于该命令不返回结果集，而是将结果存放在destination集合中，如果destination已经存在, 则将其覆盖重写 sdiffstore(dest, keys, *args) SINTER SINTER key [key …] 返回指定所有的集合的成员的交集 sinter(keys, *args) SINTERSTORE SINTERSTORE destination key [key …] 与SINTER命令类似，但是它并不是直接返回结果集，而是将结果保存在 destination集合中，如果destination集合存在, 则会被重写 sinterstore(dest, keys, *args) SUNION SUNION key [key …] 返回给定的多个集合的并集中的所有成员 sunion(keys, *args) SUNIONSTORE SUNIONSTORE destination key [key …] 类似于SUNION命令，不同的是它并不返回结果集，而是将结果存储在destination集合中，如果destination已经存在，则将其覆盖. sunionstore(dest, keys, *args) 这些命令分别是并集运算、交集运算和差集运算这三个基本集合操作的“返回结果”版本和“存储结果”版本，下面这个交互示例展示了这些命令的基本使用12345678910&gt;&gt;&gt; r.sadd('skey1', 'a', 'b', 'c', 'd')4&gt;&gt;&gt; r.sadd('skey2', 'c', 'd', 'e', 'f')4&gt;&gt;&gt; r.sdiff('skey1', 'skey2')&#123;b'b', b'a'&#125;&gt;&gt;&gt; r.sinter('skey1', 'skey2')&#123;b'c', b'd'&#125;&gt;&gt;&gt; r.sunion('skey1', 'skey2')&#123;b'd', b'a', b'f', b'e', b'c', b'b'&#125; 和Python的集合相比，Redis的集合除了可以被多个客户端远程地进行访问之外，其他的语义和功能基本都是相同的。 散列首先介绍一些常用的添加和删除键值对的Redis散列命令 命令 用例 描述 redis-py API HMGET HMGET key field [field …] 返回key指定的散列中指定字段的值 hmget(name, keys, *args) HMSET HMSET key field value [field value …] 设置key指定的散列中指定字段的值，该命令将重写所有在散列中存在的字段，如果key指定的散列不存在，会创建一个新的散列并与key关联 hmset(name, mapping) HDEL HDEL key field [field …] 从key指定的散列中移除指定的域，在散列中不存在的域将被忽略，如果key指定的散列不存在，它将被认为是一个空的散列，该命令将返回0 hdel(name, *keys) HLEN HLEN key 返回key指定的散列包含的字段的数量 hlen(name) 其中，HDEL命令已经介绍过了，而HLEN以及用于一次读取或设置多个键的HMGET和HMSET则是新出现的命令。它们既可以给用户带来方便，又可以通过减少命令的调用次数以及客户端与Redis之间的通信往返次数来提升Redis的性能。 下面这个交互示例展示了这些命令的使用方法12345678&gt;&gt;&gt; r.hmset('hash-key', &#123;'k1':'v1','k2':'v2','k3':'v3'&#125;)True&gt;&gt;&gt; r.hmget('hash-key', ['k2', 'k3'])[b'v2', b'v3']&gt;&gt;&gt; r.hlen('hash-key')3&gt;&gt;&gt; r.hdel('hash-key', 'k1', 'k3')2 之前的学习笔记(一)介绍的HGET命令和HSET命令分别是HMGET和HMSET命令的单参数版本。因为HDEL已经可以同时删除多个键值对了，所以Redis没有实现HMDEL命令。 下表列出了散列的其他几个批量操作命令，以及一些和字符串操作类似的散列命令。 命令 用例 描述 redis-py API HEXISTS HEXISTS key field 检查给定键是否存在于散列中 hexists(name, key) HKEYS HKEYS key 返回散列包含的所有键 hkeys(name) HVALS HVALS key 返回散列包含的所有值 hvals(name) HGETALL HGETALL key 返回散列包含的所有键值对 hgetall(name) HINCRBY HINCRBY key field increment 将键存储的值加上整数increment hincrby(name, key, amount=1) HINCRBYFLOAT HINCRBYFLOAT key field increment 将键存储的值加上浮点数increment hincrbyfloat(name, key, amount=1.0) 下面这个交互示例展示了这些命令的使用方法12345678910&gt;&gt;&gt; r.hmset('hash-key2', &#123;'short':'hello', 'long':1000*1&#125;)True&gt;&gt;&gt; r.hkeys('hash-key2')[b'short', b'long']&gt;&gt;&gt; r.hexists('hash-key2', 'num')False&gt;&gt;&gt; r.hincrby('hash-key2', 'num')1&gt;&gt;&gt; r.hexists('hash-key2', 'num')True 在对散列进行处理时，如果键值对的值的体积非常大，那么用户可以先用HKEYS获取散列的所有键，然后只获取必要的值，这样可以有效地减少需要传输的数据量，避免服务器阻塞。 有序集合下表展示了一些常用的有序集合命令，大部分在第一章都有介绍 命令 用例 描述 redis-py API ZADD ZADD key score member [score member …] 将带有给定分值的成员添加到有序集合中 zadd(name, args, *kwargs) ZREM ZREM key member [member …] 移除给定的成员，并返回被移除成员的数量 zrem(name, *values) ZCARD ZCARD key 返回有序集合包含的成员数量 zcard(name) ZINCRBY ZINCRBY key increment member 将member成员的分值加上increment zincrby(name, value, amount=1) ZCOUNT ZCOUNT key min max 返回分值介于min和max之间的成员数量 zcount(name, min, max) ZRANK ZRANK key member 返回成员member在有序集合中的排名 zrank(name, value) ZSCORE ZSCORE key member 返回成员member的分值 zscore(name, value) ZRANGE ZRANGE key start stop [WITHSCORES] 返回排名介于start和stop之间的成员，如果给定了可选的WITHSCORES选项，那么命令会将成员的分值也一并返回 zrange(name, start, end, desc=False, withscores=False, score_cast_func=) 下面这个交互示例展示了Redis中的一些常用的有序集合命令12345678910111213141516&gt;&gt;&gt; r.zadd('zset-key', 3, 'a', 2, 'b', 1, 'c')3&gt;&gt;&gt; r.zcard('zset-key')3&gt;&gt;&gt; r.zincrby('zset-key', 'c', 3)4.0&gt;&gt;&gt; r.zscore('zset-key', 'b')2.0&gt;&gt;&gt; r.zrank('zset-key', 'c')2&gt;&gt;&gt; r.zcount('zset-key', 0, 3)2&gt;&gt;&gt; r.zrem('zset-key', 'b')1&gt;&gt;&gt; r.zrange('zset-key', 0, -1, withscores=True)[(b'a', 3.0), (b'c', 4.0)] 其中在Python客户端用StrictRedis客户端类执行ZADD命令需要先输入分值，再输入成员，这也是Redis的标准，而Redis客户端类则截然相反。 下表展示了另外一下非常有用的有序集合命令 命令 用例 描述 redis-py API ZREVRANK ZREVRANK key member 返回有序集合里成员member的排名，成员按照分值从大到小排列 zrevrank(name, value) ZREVRANGE ZREVRANGE key start stop [WITHSCORES] 返回有序集合给定排名范围内的成员，成员按照分值从大到小排列 zrevrange(name, start, end, withscores=False, score_cast_func=) ZRANGEBYSCORE ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 返回有序集合中指定分数区间内的成员 zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=) ZREVRANGEBYSCORE ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count] 返回有序集合中指定分数区间内的成员，分数由高到低排序。 zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=) ZREMRANGEBYRANK ZREMRANGEBYRANK key start stop 移除有序集key中，指定排名(rank)区间内的所有成员 zremrangebyrank(name, min, max) ZREMRANGEBYSCORE ZREMRANGEBYSCORE key min max 移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员 zremrangebyscore(name, min, max) ZINTERSTORE ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM MIN MAX] 计算给定的numkeys个有序集合的交集，并且把结果放到destination中 zinterstore(dest, keys, aggregate=None) ZUNIONSTORE ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM MIN MAX] 计算给定的numkeys个有序集合的并集，并且把结果放到destination中。 zunionstore(dest, keys, aggregate=None) 其中有几个是没有介绍过的新命令，除了使用逆序来处理有序集合之外，ZREV*命令的工作方式和相对应的非逆序命令的工作方式完全一样(逆序就是指元素按照分值从大到小地排列)。 下面这个交互示例展示了ZINTERSTORE和ZUNIONSTORE命令的用法123456789101112131415161718&gt;&gt;&gt; r.zadd('zset-1', 1, 'a', 2, 'b', 3, 'c')3&gt;&gt;&gt; r.zadd('zset-2', 4, 'b', 1, 'c', 0, 'd')3&gt;&gt;&gt; r.zinterstore('zset-i', ['zset-1', 'zset-2'])2&gt;&gt;&gt; r.zrange('zset-i', 0, -1, withscores=True)[(b'c', 4.0), (b'b', 6.0)]&gt;&gt;&gt; r.zunionstore('zset-u', ['zset-1', 'zset-2'], aggregate='min')4&gt;&gt;&gt; r.zrange('zset-u', 0, -1, withscores=True)[(b'd', 0.0), (b'a', 1.0), (b'c', 1.0), (b'b', 2.0)]&gt;&gt;&gt; r.sadd('set-1', 'a', 'd')2&gt;&gt;&gt; r.zunionstore('zset-u2', ['zset-1', 'zset-2', 'set-1'])4&gt;&gt;&gt; r.zrange('zset-u2', 0, -1, withscores=True)[(b'd', 1.0), (b'a', 2.0), (b'c', 4.0), (b'b', 6.0)] 用户可以在执行交并运算时传入不同的聚合函数，共有sum、min、max三种可选；用户还可以把集合作为输入传给ZINTERSTORE和ZUNIONSTORE，命令会将集合看作是成员分值全为1的有序集合来处理。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis, Python","slug":"Redis-Python","permalink":"http://yoursite.com/tags/Redis-Python/"}]},{"title":"Redis学习笔记(一)：初识Redis","slug":"Redis-1","date":"2017-03-25T12:18:54.000Z","updated":"2017-03-27T09:12:22.000Z","comments":true,"path":"2017/03/25/Redis-1/","link":"","permalink":"http://yoursite.com/2017/03/25/Redis-1/","excerpt":"Redis简介Redis是一个速度极快的非关系数据库，也就是我们所说的NoSQL数据库(non-relational database)，它可以存储键(key)与5种不同类型的值(value)之间的映射(mapping)，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展性能，并且它还提供了多种语言的API。","text":"Redis简介Redis是一个速度极快的非关系数据库，也就是我们所说的NoSQL数据库(non-relational database)，它可以存储键(key)与5种不同类型的值(value)之间的映射(mapping)，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展性能，并且它还提供了多种语言的API。 Redis与memcached及其他类型数据库对比Redis经常被拿来与memcached进行比较，两者都可用于存储键值映射，性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，而且Redis除了能存储普通的字符串键，还能存储其他4种数据结构，使得Redis可以用于解决更为广泛的问题，并且即可以作为主数据库使用，又可以作为其他存储系统的辅助数据库。 下表展示了Redis与memcached，MySQL以及MongoDB的特性与功能。 名称 类型 数据存储选项 查询类型 附加功能 Redis 使用内存存储的非关系数据库 字符串、列表、集合、散列表、有序集合 每种数据类型专属的命令，以及批量操作和不完全的事务支持 发布与订阅，主从复制，持久化，脚本 memcached 使用内存存储的键值缓存 键值之间的映射 创建、读取、删除、更新等命令 多线程服务器，用于提升性能 MySQL 关系数据库 每个数据库可以包含多个表，每个表可以包含多个行；可以处理多个表的视图；支持空间和第三方扩展 SELECT、INSERT、UPDATE、DELETE、函数、存储过程 支持ACID性质(需要使用InnoDB)，主从复制，主主复制 MongoDB 使用硬盘存储(on-disk)的非关系文档存储 每个数据库可以包含多个表，每个表可以包含多个无schema的BSON文档 创建、读取、更新、删除、条件查询等命令 支持map-reduce操作，主从复制，分片，空间索引 Redis安装(mac)首先下载用于安装Rudix的引导脚本，并安装Rudix12$ curl -O http://rudix.google.code.com/hg/Ports/rudix/rudix.Py$ sudo python rudix.py install rudix 然后使用命令Rudix安装Redis，若能成功启动Redis服务器则安装成功12$ sudo rudix install redis$ redis-server 最后用pip为Python安装Redis客户端库1$ sudo pip install redis Redis数据结构简介Redis可以存储键与5种不同数据结构类型之间的映射，分别是STRING(字符串)、LIST(列表)、SET(集合)、HASH(散列)、ZSET(有序集合)。有一部分命令对于这5种数据结构是通用的，如DEL、TYPE、RENAME等；但也有一部分命令只能对特定的一种或者两种结构使用。 下表从结构存储的值及读写能力对比了Redis的5种数据结构。 结构类型 结构存储的值 结构的读写能力 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数进行自增或自减操作 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表两端推入或弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或多个元素；根据值查找或移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串互不相同 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有键值对 ZSET 字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素 Redis字符串下表展示了3种简单的字符串命令： 命令 行为 GET 获取存储在给定键中的值 SET 设置存储在给定键中的值 DEL 删除存储在给定键中的值(该命令可用于所有类型) SET、GET、DEL的使用示例：12345678910$ redis-cli127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello\"world\"127.0.0.1:6379&gt; del hello(integer) 1127.0.0.1:6379&gt; get hello(nil)127.0.0.1:6379&gt; SET命令在执行成功时返回OK，Python客户端会将这个OK转换为True；DEL命令在执行成功时将会返回被成功删除的值的数量；GET命令在尝试得到不存在的值时，将会返回一个nil，Python客户端会将这个nil转换为None。 Redis列表下表展示了6种简单的列表命令： 命令 行为 LPUSH(RPUSH) 将给定值推入列表的左端(右端) LPOP(RPOP) 从列表的左端(右端)弹出一个值，并返回被弹出的值 LINDEX 获取列表在给定位置上的单个值 LRANGE 获取列表在给定范围上的所有值 RPUSH、LRANGE、LINDEX、LPOP的使用示例12345678910111213141516171819$ redis-cli127.0.0.1:6379&gt; rpush list-key item(integer) 1127.0.0.1:6379&gt; rpush list-key item2(integer) 2127.0.0.1:6379&gt; rpush list-key item(integer) 3127.0.0.1:6379&gt; lrange list-key 0 -11) \"item\"2) \"item2\"3) \"item\"127.0.0.1:6379&gt; lindex list-key 1\"item2\"127.0.0.1:6379&gt; lpop list-key \"item\"127.0.0.1:6379&gt; lrange list-key 0 -11) \"item2\"2) \"item\"127.0.0.1:6379&gt; RPUSH和LPUSH命令在执行成功后会返回当前列表的长度；列表索引范围从0开始，到-1结束，可以取出列表包含的所有元素；使用LINDEX可以从列表中取出单个元素。 Redis集合Redis的集合和列表都可以存储多个字符串，它们的不同之处在于，列表可以存储多个相同的字符串，而集合则通过散列表来保证自己存储的每个字符串都是不同的(这些散列表只有键)。 下表展示了6种简单的集合命令： 命令 行为 SADD 将给定元素添加到集合 SMEMBERS 返回集合包含的所有元素 SISMEMBER 检查给定元素是否存在于集合中 SREM 如果给定的元素存在于集合中，那么移除这个元素 SADD、SMEMBERS、SISMEMBER、SREM的使用示例12345678910111213141516171819202122232425$ redis-cli127.0.0.1:6379&gt; sadd set-key item(integer) 1127.0.0.1:6379&gt; sadd set-key item2(integer) 1127.0.0.1:6379&gt; sadd set-key item3(integer) 1127.0.0.1:6379&gt; sadd set-key item(integer) 0127.0.0.1:6379&gt; smembers set-key1) \"item2\"2) \"item3\"3) \"item\"127.0.0.1:6379&gt; sismember set-key item4(integer) 0127.0.0.1:6379&gt; sismember set-key item(integer) 1127.0.0.1:6379&gt; srem set-key item2(integer) 1127.0.0.1:6379&gt; srem set-key item2(integer) 0127.0.0.1:6379&gt; smembers set-key1) \"item3\"2) \"item\"127.0.0.1:6379&gt; SADD命令返回1表示成功添加到集合中，返回0表示该元素已存在于集合中；SMEMBERS命令获取到的元素组成的序列将会被Python客户端转换为Python集合；Python客户端会返回一个布尔值来表示SISMEMBER命令的检查结果；SREM命令会返回被移除元素的数量。 Redis散列Redis的散列就像一个微型Redis，它可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串也可以是数值。可以将散列看做文档数据库里面的文档，还可以看做是关系数据库里面的行，因为散列、文档和行都允许用户同时访问或修改一个或多个域(field)。 下表展示了4种简单的列表命令： 命令 行为 HSET 在散列里面关联给定的键值对 HGET 获取指定散列键的值 HGETALL 获取散列包含的所有键值对 HDEL 如果给定键存在于散列里面，那么移除这个键 HSET、HGET、HGETALL、HDEL的使用示例12345678910111213141516171819202122$ redis-cli127.0.0.1:6379&gt; hset hash-key sub-key1 value1(integer) 1127.0.0.1:6379&gt; hset hash-key sub-key2 value2(integer) 1127.0.0.1:6379&gt; hset hash-key sub-key1 value1(integer) 0127.0.0.1:6379&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\"3) \"sub-key2\"4) \"value2\"127.0.0.1:6379&gt; hdel hash-key sub-key2(integer) 1127.0.0.1:6379&gt; hdel hash-key sub-key2(integer) 0127.0.0.1:6379&gt; hget hash-key sub-key1\"value1\"127.0.0.1:6379&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\"127.0.0.1:6379&gt; HSET返回一个值来表示给定的键是否已经存在于散列里面；Python客户端会把HGETALL命令获取的整个散列转换为一个Python字典；HDEL命令执行后会返回一个值来表示给定的键在移除之前是否存在于散列里面。 Redis有序集合有序集合和散列一样，都用于存储键值对：其中有序集合的每个键称为成员（member），都是独一无二的，而有序集合的每个值称为分值（score），都必须是浮点数。有序集合是Redis里面唯一既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。 下表展示了4种简单的有序集合命令： 命令 行为 ZADD 将一个带有给定分值的成员添加到有序集合里面 ZRANGE 根据元素在有序排列中所处的位置，从有序集合里获取多个元素 ZRANGEBYSCORE 获取有序集合在给定分值范围内的所有元素 ZREM 如果给定成员存在于有序集合，那么移除这个成员 ZADD、ZRANGE、ZRANGEBYSCORE、ZREM的使用示例1234567891011121314151617181920212223$ redis-cli127.0.0.1:6379&gt; zadd zset-key 728 member1(integer) 1127.0.0.1:6379&gt; zadd zset-key 982 member0(integer) 1127.0.0.1:6379&gt; zadd zset-key 982 member0(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) \"member1\"2) \"728\"3) \"member0\"4) \"982\"127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores1) \"member1\"2) \"728\"127.0.0.1:6379&gt; zrem zset-key member1(integer) 1127.0.0.1:6379&gt; zrem zset-key member1(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) \"member0\"2) \"982\"127.0.0.1:6379&gt; 在尝试向有序集合添加元素的时候，ZADD命令会返回新添加元素的数量；ZRANGE命令获取有序集合包含的所有元素，这些元素会按照分值进行排序，Python客户端会将这些分值转换成浮点数；ZRANGEBYSCORE命令也可以根据分值来获取有序集合的其中一部分元素；ZREM命令在移除有序集合元素的时候，命令会返回被移除元素的数量。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis, Python","slug":"Redis-Python","permalink":"http://yoursite.com/tags/Redis-Python/"}]}]}