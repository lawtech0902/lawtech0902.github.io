<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LawTech&#39;s Blog</title>
  <subtitle>不破不立</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-16T06:44:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LawTech.</name>
    <email>584563542@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python分布式爬虫打造搜索引擎项目学习笔记——Scrapy简单入门</title>
    <link href="http://yoursite.com/2017/04/16/scrapy-simple-intro/"/>
    <id>http://yoursite.com/2017/04/16/scrapy-simple-intro/</id>
    <published>2017-04-16T06:18:54.000Z</published>
    <updated>2017-04-16T06:44:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h2><p>开始爬取前，首先需要创建一个新的Scrapy项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject tutorial</div></pre></td></tr></table></figure>
<p>该命令将会创建包含下列内容的 tutorial 目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tutorial/</div><div class="line">  scrapy.cfg </div><div class="line">  tutorial/ </div><div class="line">    __init__.py </div><div class="line">    items.py </div><div class="line">    pipelines.py</div><div class="line">    settings.py </div><div class="line">    spiders/ </div><div class="line">      __init__.py </div><div class="line">      ...</div></pre></td></tr></table></figure>
<p>这些文件分别是:</p>
<ul>
<li>scrapy.cfg：项目的配置文件</li>
<li>tutorial/：该项目的 python 模块，之后我们将在此加入代码。 </li>
<li>tutorial/items.py：项目中的 item 文件。 </li>
<li>tutorial/pipelines.py：项目中的 pipelines 文件。 </li>
<li>tutorial/settings.py：项目的设置文件。 </li>
<li>tutorial/spiders/：放置 spider 代码的目录。</li>
</ul>
<h2 id="定义-Item"><a href="#定义-Item" class="headerlink" title="定义 Item"></a><strong>定义 Item</strong></h2><p>Item 是保存爬取到的数据的容器；其使用方法和 python 字典类似， 并且提供了额外保护机制来避免拼写错误导 致的未定义字段错误。</p>
<p>类似在 ORM 中做的一样，您可以通过创建一个<code>scrapy.Item</code>类， 并且定义类型为<code>scrapy.Field</code>的类属性来定义一个 Item。 (如果不了解 ORM, 不用担心，您会发现这个步骤非常简单)</p>
<p>首先根据需要从 dmoz.org 获取到的数据对 item 进行建模。 我们需要从 dmoz 中获取名字，url，以及网站的描 述。 对此，在 item 中定义相应的字段。编辑<code>tutorial</code>目录中的<code>items.py</code>文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozItem</span><span class="params">(scrapy.Item)</span>:</span> </div><div class="line">    title = scrapy.Field() </div><div class="line">    link = scrapy.Field() </div><div class="line">    desc = scrapy.Field()</div></pre></td></tr></table></figure>
<p>可能一开始这有些复杂，但是通过定义 item， 我们可以很方便的使用 Scrapy 的其他方法，而这些方法需要知道我们的 item 的定义。</p>
<h2 id="编写第一个爬虫"><a href="#编写第一个爬虫" class="headerlink" title="编写第一个爬虫"></a><strong>编写第一个爬虫</strong></h2><p>Spider 是用户编写用于从单个网站(或者一些网站)爬取数据的类。 </p>
<p>其包含了一个用于下载的初始 URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方 法。 </p>
<p>为了创建一个 Spider，我们必须继承<code>scrapy.Spider</code>类， 且定义以下三个属性: </p>
<ul>
<li><code>name</code> : 用于区别 Spider。 该名字必须是唯一的，您不可以为不同的 Spider 设定相同的名字。</li>
<li><code>start_urls</code> : 包含了 Spider 在启动时进行爬取的 url 列表。 因此，第一个被获取到的页面将是其中之一。 后续的 URL 则从初始的 URL 获取到的数据中提取。 </li>
<li><code>parse()</code> : spider 的一个方法。 被调用时，每个初始 URL 完成下载后生成的<code>Response</code>对象将会作为 唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成 item)以及生成需 要进一步处理的 URL 的<code>Request</code>对象。 </li>
</ul>
<p>以下为我们的第一个 Spider 代码，保存在<code>tutorial/spiders</code>目录下的<code>dmoz_spider.py</code>文件中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"dmoz"</span></div><div class="line">    allow_domains = [<span class="string">"dmoz.org"</span>]</div><div class="line">    start_urls = [</div><div class="line">      <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</div><div class="line">      <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span>  </div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        filename = response.url.split(<span class="string">"/"</span>)[<span class="number">-2</span>] </div><div class="line">        <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f: </div><div class="line">            f.write(response.body)</div></pre></td></tr></table></figure>
<p>其中，allow_domains是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页。</p>
<h3 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a><strong>爬取</strong></h3><p>进入项目的根目录，执行以下命令启动spider</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl dmoz</div></pre></td></tr></table></figure>
<p><code>crawl dmoz</code>启动用于爬取<code>dmoz.org</code>的 spider，可以得到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">2017-04-15 21:51:39 [scrapy.utils.log] INFO: Scrapy 1.3.3 started (bot: tutorial)</div><div class="line">2017-04-15 21:51:39 [scrapy.utils.log] INFO: Overridden settings: &#123;&apos;BOT_NAME&apos;: &apos;tutorial&apos;, &apos;ROBOTSTXT_OBEY&apos;: True, &apos;NEWSPIDER_MODULE&apos;: &apos;tutorial.spiders&apos;, &apos;SPIDER_MODULES&apos;: [&apos;tutorial.spiders&apos;]&#125;</div><div class="line">2017-04-15 21:51:39 [scrapy.middleware] INFO: Enabled extensions:</div><div class="line">[&apos;scrapy.extensions.corestats.CoreStats&apos;,</div><div class="line"> &apos;scrapy.extensions.logstats.LogStats&apos;,</div><div class="line"> &apos;scrapy.extensions.telnet.TelnetConsole&apos;]</div><div class="line">2017-04-15 21:51:39 [scrapy.middleware] INFO: Enabled downloader middlewares:</div><div class="line">[&apos;scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.retry.RetryMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.stats.DownloaderStats&apos;]</div><div class="line">2017-04-15 21:51:39 [scrapy.middleware] INFO: Enabled spider middlewares:</div><div class="line">[&apos;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.referer.RefererMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.depth.DepthMiddleware&apos;]</div><div class="line">2017-04-15 21:51:39 [scrapy.middleware] INFO: Enabled item pipelines:</div><div class="line">[]</div><div class="line">2017-04-15 21:51:39 [scrapy.core.engine] INFO: Spider opened</div><div class="line">2017-04-15 21:51:39 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</div><div class="line">2017-04-15 21:51:39 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023</div><div class="line">2017-04-15 21:51:41 [scrapy.core.engine] DEBUG: Crawled (403) &lt;GET http://www.dmoz.org/robots.txt&gt; (referer: None)</div><div class="line">2017-04-15 21:51:41 [scrapy.core.engine] DEBUG: Crawled (403) &lt;GET http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt; (referer: None)</div><div class="line">2017-04-15 21:51:41 [scrapy.spidermiddlewares.httperror] INFO: Ignoring response &lt;403 http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt;: HTTP status code is not handled or not allowed</div><div class="line">2017-04-15 21:51:41 [scrapy.core.engine] DEBUG: Crawled (403) &lt;GET http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&gt; (referer: None)</div><div class="line">2017-04-15 21:51:41 [scrapy.spidermiddlewares.httperror] INFO: Ignoring response &lt;403 http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&gt;: HTTP status code is not handled or not allowed</div><div class="line">2017-04-15 21:51:41 [scrapy.core.engine] INFO: Closing spider (finished)</div><div class="line">2017-04-15 21:51:41 [scrapy.statscollectors] INFO: Dumping Scrapy stats:</div><div class="line">&#123;&apos;downloader/request_bytes&apos;: 734,</div><div class="line"> &apos;downloader/request_count&apos;: 3,</div><div class="line"> &apos;downloader/request_method_count/GET&apos;: 3,</div><div class="line"> &apos;downloader/response_bytes&apos;: 3525,</div><div class="line"> &apos;downloader/response_count&apos;: 3,</div><div class="line"> &apos;downloader/response_status_count/403&apos;: 3,</div><div class="line"> &apos;finish_reason&apos;: &apos;finished&apos;,</div><div class="line"> &apos;finish_time&apos;: datetime.datetime(2017, 4, 15, 13, 51, 41, 968931),</div><div class="line"> &apos;log_count/DEBUG&apos;: 4,</div><div class="line"> &apos;log_count/INFO&apos;: 9,</div><div class="line"> &apos;response_received_count&apos;: 3,</div><div class="line"> &apos;scheduler/dequeued&apos;: 2,</div><div class="line"> &apos;scheduler/dequeued/memory&apos;: 2,</div><div class="line"> &apos;scheduler/enqueued&apos;: 2,</div><div class="line"> &apos;scheduler/enqueued/memory&apos;: 2,</div><div class="line"> &apos;start_time&apos;: datetime.datetime(2017, 4, 15, 13, 51, 39, 764494)&#125;</div><div class="line">2017-04-15 21:51:41 [scrapy.core.engine] INFO: Spider closed (finished)</div></pre></td></tr></table></figure>
<p>查看包含<code>[dmoz]</code>的输出，可以看到输出的 log 中包含定义在<code>start_urls</code>的初始 URL，并且与 spider 中是一 一对应的。在 log 中可以看到其没有指向其他页面( (<code>referer:None</code>) )。 除此之外，更有趣的事情发生了。就像我们 parse 方法指定的那样，有两个包含 url 所对应的内容的文件被创建 了: Book，Resources 。</p>
<h3 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a><strong>发生了什么？</strong></h3><p>Scrapy 为 Spider 的<code>start_urls</code>属性中的每个 URL 创建了<code>scrapy.Request</code>对象，并将<code>parse</code>方法作为回调函数(callback)赋值给了<code>Request</code>。 <code>Request</code>对象经过调度，执行生成<code>scrapy.http.Response</code>对象并送回给<code>spider parse()</code>方法。</p>
<h3 id="提取-Item"><a href="#提取-Item" class="headerlink" title="提取 Item"></a><strong>提取 Item</strong></h3><h4 id="Selectors-选择器简介"><a href="#Selectors-选择器简介" class="headerlink" title="Selectors 选择器简介"></a><strong>Selectors 选择器简介</strong></h4><p>从网页中提取数据有很多方法。Scrapy 使用了一种基于 XPath 和 CSS 表达式机制: <code>Scrapy Selectors</code>。关于 selector 和其他提取机制的信息请参考<code>Selector</code>文档。 </p>
<p>关于Xpath的简单使用方法，可以查看之前的一篇博客<a href="http://lawtech0902.com/2017/04/11/xpath-usage/" target="_blank" rel="external">Python分布式爬虫打造搜索引擎项目学习笔记——Xpath用法</a></p>
<p>为了配合 XPath，Scrapy 除了提供了<code>Selector</code>之外，还提供了方法来避免每次从 response 中提取数据时生成 selector 的麻烦。</p>
<p>Selector 有四个基本的方法：</p>
<ul>
<li><code>xpath()</code>：传入 xpath 表达式，返回该表达式所对应的所有节点的 selector list 列表 。</li>
<li><code>css()</code>：传入 CSS 表达式，返回该表达式所对应的所有节点的 selector list 列表。</li>
<li><code>extract()</code>：序列化该节点为 unicode 字符串并返回 list。</li>
<li><code>re()</code>：根据传入的正则表达式对数据进行提取，返回 unicode 字符串 list 列表。</li>
</ul>
<h4 id="在-Shell-中尝试-Selector-选择器"><a href="#在-Shell-中尝试-Selector-选择器" class="headerlink" title="在 Shell 中尝试 Selector 选择器"></a><strong>在 Shell 中尝试 Selector 选择器</strong></h4><p>为了介绍 Selector 的使用方法，接下来我们将要使用内置的 Scrapy shell。Scrapy Shell 需要我们预装好 IPython(一个扩展的 Python 终端)。 我们需要进入项目的根目录，执行下列命令来启动 shell:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy shell &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;</div></pre></td></tr></table></figure>
<p>Shell 的输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2017-04-15 22:04:22 [scrapy.core.engine] INFO: Spider opened</div><div class="line">2017-04-15 22:04:23 [scrapy.core.engine] DEBUG: Crawled (403) &lt;GET http://www.dmoz.org/robots.txt&gt; (referer: None)</div><div class="line">2017-04-15 22:04:24 [scrapy.core.engine] DEBUG: Crawled (403) &lt;GET http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt; (referer: None)</div><div class="line">[s] Available Scrapy objects:</div><div class="line">[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)</div><div class="line">[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x109728ac8&gt;</div><div class="line">[s]   item       &#123;&#125;</div><div class="line">[s]   request    &lt;GET http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt;</div><div class="line">[s]   response   &lt;403 http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt;</div><div class="line">[s]   settings   &lt;scrapy.settings.Settings object at 0x10a2a0a58&gt;</div><div class="line">[s]   spider     &lt;DefaultSpider &apos;default&apos; at 0x10a4dc3c8&gt;</div><div class="line">[s] Useful shortcuts:</div><div class="line">[s]   fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)</div><div class="line">[s]   fetch(req)                  Fetch a scrapy.Request and update local objects</div><div class="line">[s]   shelp()           Shell help (print this help)</div><div class="line">[s]   view(response)    View response in a browser</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>当 shell 载入后，我们将得到一个包含 response 数据的本地 response 变量。输入 response.body 将输出 resp onse 的包体，输出 response.headers 可以看到 response 的包头。 </p>
<p>更为重要的是，当输入 response.selector 时， 我们将获取到一个可以用于查询返回数据的 selector(选择器)， 以及映射到 response.selector.xpath() 、response.selector.css() 的 快捷方法(shortcut): response.xpat h() 和 response.css() 。 </p>
<p>下面就来试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; response.xpath(&apos;//title&apos;)</div><div class="line">[&lt;Selector xpath=&apos;//title&apos; data=&apos;&lt;title&gt;DMOZ&lt;/title&gt;&apos;&gt;]</div><div class="line">&gt;&gt;&gt; response.xpath(&apos;//title&apos;).extract()</div><div class="line">[&apos;&lt;title&gt;DMOZ&lt;/title&gt;&apos;]</div><div class="line">&gt;&gt;&gt; response.xpath(&apos;//title/text()&apos;)</div><div class="line">[&lt;Selector xpath=&apos;//title/text()&apos; data=&apos;DMOZ&apos;&gt;]</div><div class="line">&gt;&gt;&gt; response.xpath(&apos;//title/text()&apos;).extract()</div><div class="line">[&apos;DMOZ&apos;]</div></pre></td></tr></table></figure>
<h4 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a><strong>提取数据</strong></h4><p>现在，我们来尝试从这些页面中提取些有用的数据。 </p>
<p>我们可以在终端中输入 response.body 来观察 HTML 源码并确定合适的 XPath 表达式。不过，这任务非常无聊且不易。您可以考虑使用 Firefox 的 Firebug 扩展来使得工作更为轻松。</p>
<p>在查看了网页的源码后，您会发现网站的信息是被包含在 第二个 <ul> 元素中。 </ul></p>
<p>我们可以通过这段代码选择该页面中网站列表里所有 <li> 元素:</li></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.xpath(&apos;//ul/li&apos;)</div></pre></td></tr></table></figure>
<p>网站的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.xpath(&apos;//ul/li/text()&apos;).extract()</div></pre></td></tr></table></figure>
<p>网站的标题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.xpath(&apos;//ul/li/a/text()&apos;).extract()</div></pre></td></tr></table></figure>
<p>以及网站的链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.xpath(&apos;//ul/li/a/@href&apos;).extract()</div></pre></td></tr></table></figure>
<p>之前提到过，每个 <code>.xpath()</code> 调用返回 selector 组成的 list，因此我们可以拼接更多的  <code>.xpath()</code> 来进一步获取某个节点。我们将在下边使用这样的特性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> response <span class="keyword">in</span> response.xpath(<span class="string">'//ul/li'</span>):</div><div class="line">	title = response.xpath(<span class="string">'a/text()'</span>).extract()</div><div class="line">    link = response.xpath(<span class="string">'a/@href'</span>).extract()</div><div class="line">    desc = response.xpath(<span class="string">'text()'</span>).extract()</div><div class="line">    print(title, link, desc)</div></pre></td></tr></table></figure>
<p>在我们的 spider 中加入如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"dmoz"</span></div><div class="line">    allow_domains = [<span class="string">"dmoz.org"</span>]</div><div class="line">    start_urls = [      	     <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> response.xpath(<span class="string">'//ul/li'</span>):</div><div class="line">            title = response.xpath(<span class="string">'a/text()'</span>).extract()</div><div class="line">            link = response.xpath(<span class="string">'a/@href'</span>).extract()</div><div class="line">            desc = response.xpath(<span class="string">'text()'</span>).extract()</div><div class="line">            print(title, link, desc)</div></pre></td></tr></table></figure>
<p>现在尝试再次爬取 dmoz.org，您将看到爬取到的网站信息被成功输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl dmoz</div></pre></td></tr></table></figure>
<h3 id="使用-Item"><a href="#使用-Item" class="headerlink" title="使用 Item"></a><strong>使用 Item</strong></h3><p>Item 对象是自定义的 python 字典。您可以使用标准的字典语法来获取到其每个字段的值。(字段就是我们之前用 Field 赋值的属性):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; item = DmozItem() </div><div class="line">&gt;&gt;&gt; item[&apos;title&apos;] = &apos;Example title&apos; </div><div class="line">&gt;&gt;&gt; item[&apos;title&apos;] </div><div class="line">&apos;Example title&apos;</div></pre></td></tr></table></figure>
<p>一般来说，Spider 将会将爬取到的数据以 Item 对象返回。所以为了将爬取的数据返回，我们最终的代码将是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="keyword">from</span> tutorial.items <span class="keyword">import</span> DmozItem</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"dmoz"</span></div><div class="line">    allow_domains = [<span class="string">"dmoz.org"</span>]</div><div class="line">    start_urls = [</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</div><div class="line">        <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> response.xpath(<span class="string">'//ul/li'</span>):</div><div class="line">            item = DmozItem()</div><div class="line">            item[<span class="string">'title'</span>] = response.xpath(<span class="string">'a/text()'</span>).extract()</div><div class="line">            item[<span class="string">'link'</span>] = response.xpath(<span class="string">'a/@href'</span>).extract()</div><div class="line">            item[<span class="string">'desc'</span>] = response.xpath(<span class="string">'text()'</span>).extract()</div><div class="line">            <span class="keyword">yield</span> item</div></pre></td></tr></table></figure>
<p>现在对 dmoz.org 进行爬取将会产生 <code>DmozItem</code> 对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[dmoz] DEBUG: Scraped from &lt;200 http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt; &#123;&apos;desc&apos;: [u&apos; - By David Mertz; Addison Wesley. Book in progress, full text, ASCII format. Asks for feedback. [author webs &apos;link&apos;: [u&apos;http://gnosis.cx/TPiP/&apos;], &apos;title&apos;: [u&apos;Text Processing in Python&apos;]&#125; [dmoz] DEBUG: Scraped from &lt;200 http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt; &#123;&apos;desc&apos;: [u&apos; - By Sean McGrath; Prentice Hall PTR, 2000, ISBN 0130211192, has CD-ROM. Methods to build XML applic &apos;link&apos;: [u&apos;http://www.informit.com/store/product.aspx?isbn=0130211192&apos;], &apos;title&apos;: [u&apos;XML Processing with Python&apos;]&#125;</div></pre></td></tr></table></figure>
<h2 id="保存爬取到的数据"><a href="#保存爬取到的数据" class="headerlink" title="保存爬取到的数据"></a><strong>保存爬取到的数据</strong></h2><p>最简单存储爬取的数据的方式是使用 <code>Feed exports</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl dmoz -o items.json</div></pre></td></tr></table></figure>
<p>该命令将采用 JSON 格式对爬取的数据进行序列化，生成 <code>items.json</code> 文件。</p>
<p>在类似本篇教程里这样小规模的项目中，这种存储方式已经足够。 如果需要对爬取到的 item 做更多更为复杂的 操作，您可以编写 <code>Item Pipeline</code> 。 类似于我们在创建项目时对 Item 做的，用于您编写自己的 <code>tutorial/pipelines.py</code> 也被创建。 不过如果您仅仅想要保存 item，您不需要实现任何的 pipeline。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;&lt;strong&gt;创建项目&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;开始爬取前，首先需要创建一个新的Scrapy项目&lt;/p&gt;
&lt;figure class=&quot;h
    
    </summary>
    
      <category term="Scrapy" scheme="http://yoursite.com/categories/Scrapy/"/>
    
    
      <category term="Scrapy，Python" scheme="http://yoursite.com/tags/Scrapy%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>python3+Django配置mysql连接</title>
    <link href="http://yoursite.com/2017/04/14/django-py3-mysql/"/>
    <id>http://yoursite.com/2017/04/14/django-py3-mysql/</id>
    <published>2017-04-14T07:18:54.000Z</published>
    <updated>2017-04-14T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直使用的是Django1.9和Python2.7，现在使用Python3和Django1.10，发现Mysql-Python一直无法安装</p>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcgy1fem85h0fdlj30wi0p4gqc.jpg" alt=""></p>
<p>这是因为mysql官网上的版本只支持Python3.4的数据库驱动，所以Python3.5是安装不上相应的驱动的，可以使用pymysql。在虚拟环境下pip install pymysql就可以了，然后在项目目录下的<code>__init__.py</code>文件中添加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymysql</div><div class="line">pymysql.install_as_mysqldb()</div></pre></td></tr></table></figure>
<p>就可以代替Django默认使用的<code>MySQLdb</code>了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直使用的是Django1.9和Python2.7，现在使用Python3和Django1.10，发现Mysql-Python一直无法安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tKfTcgy1fem85h0fd
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django，Mysql，Python" scheme="http://yoursite.com/tags/Django%EF%BC%8CMysql%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>Python分布式爬虫打造搜索引擎项目学习笔记——Python字符编码</title>
    <link href="http://yoursite.com/2017/04/12/python-str-encode/"/>
    <id>http://yoursite.com/2017/04/12/python-str-encode/</id>
    <published>2017-04-12T12:18:54.000Z</published>
    <updated>2017-04-12T07:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python字符编码"><a href="#Python字符编码" class="headerlink" title="Python字符编码"></a><strong>Python字符编码</strong></h2><p>字符编码是计算机编程中不可回避的问题，不管你用 Python2 还是 Python3，亦或是 C++, Java 等，我都觉得非常有必要理清计算机中的字符编码概念。</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h3><ul>
<li><p>字符（Character）</p>
<p>在电脑和电信领域中，<strong>字符是一个信息单位，它是各种文字和符号的总称</strong>，包括各国家文字、标点符号、图形符号、数字等。比如，一个汉字，一个英文字母，一个标点符号等都是一个字符。</p>
</li>
<li><p>字符集（Character set）</p>
<p><strong>字符集是字符的集合</strong>。字符集的种类较多，每个字符集包含的字符个数也不同。比如，常见的字符集有 ASCII 字符集、GB2312 字符集、Unicode 字符集等，其中，ASCII 字符集共有 128 个字符，包含可显示字符（比如英文大小写字符、阿拉伯数字）和控制字符（比如空格键、回车键）；GB2312 字符集是中国国家标准的简体中文字符集，包含简化汉字、一般符号、数字等；Unicode 字符集则包含了世界各国语言中使用到的所有字符。</p>
</li>
<li><p>字符编码（Character encoding）</p>
<p><strong>字符编码，是指对于字符集中的字符，将其编码为特定的二进制数</strong>，以便计算机处理。常见的字符编码有 ASCII 编码，UTF-8 编码，GBK 编码等。一般而言，<strong>字符集</strong>和<strong>字符编码</strong>往往被认为是同义的概念，比如，对于字符集 ASCII，它除了有「字符的集合」这层含义外，同时也包含了「编码」的含义，也就是说，<strong>ASCII 既表示了字符集也表示了对应的字符编码</strong>。</p>
</li>
</ul>
<p>下面我们用一个表格做下总结：</p>
<table>
<thead>
<tr>
<th style="text-align:left">概念</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符</td>
<td style="text-align:left">一个信息单位，各种文字和符号的总称</td>
<td style="text-align:left">‘中’, ‘a’, ‘1’, ‘$’, ‘￥’, …</td>
</tr>
<tr>
<td style="text-align:left">字符集</td>
<td style="text-align:left">字符的集合</td>
<td style="text-align:left">ASCII 字符集, GB2312 字符集, Unicode 字符集</td>
</tr>
<tr>
<td style="text-align:left">字符编码</td>
<td style="text-align:left">将字符集中的字符，编码为特定的二进制数</td>
<td style="text-align:left">ASCII 编码，GB2312 编码，Unicode 编码</td>
</tr>
<tr>
<td style="text-align:left">字节</td>
<td style="text-align:left">计算机中存储数据的单元，一个 8 位（bit）的二进制数</td>
<td style="text-align:left">0x01, 0x45, …</td>
</tr>
</tbody>
</table>
<h3 id="常见字符编码简介"><a href="#常见字符编码简介" class="headerlink" title="常见字符编码简介"></a><strong>常见字符编码简介</strong></h3><p>常见的字符编码有 ASCII 编码，GBK 编码，Unicode 编码和 UTF-8 编码等等。这里，我们主要介绍 ASCII、Unicode 和 UTF-8。</p>
<ul>
<li><p>ASCII</p>
<p>计算机是在美国诞生的，人家用的是英语，而在英语的世界里，不过就是英文字母，数字和一些普通符号的组合而已。</p>
<p>在 20 世纪 60 年代，美国制定了一套字符编码方案，规定了英文字母，数字和一些普通符号跟二进制的转换关系，被称为 ASCII (American Standard Code for Information Interchange，美国信息互换标准编码) 码。</p>
<p>比如，大写英文字母 A 的二进制表示是 01000001（十进制 65），小写英文字母 a 的二进制表示是 01100001 （十进制 97），空格 SPACE 的二进制表示是 00100000（十进制 32）。</p>
</li>
<li><p>Unicode</p>
<p>ASCII 码只规定了 128 个字符的编码，这在美国是够用的。可是，计算机后来传到了欧洲，亚洲，乃至世界各地，而世界各国的语言几乎是完全不一样的，用 ASCII 码来表示其他语言是远远不够的，所以，不同的国家和地区又制定了自己的编码方案，比如中国大陆的 GB2312 编码 和 GBK 编码等，日本的 Shift_JIS 编码等等。</p>
<p>虽然各个国家和地区可以制定自己的编码方案，但不同国家和地区的计算机在数据传输的过程中就会出现各种各样的乱码（mojibake），这无疑是个灾难。</p>
<p>怎么办？想法也很简单，就是将全世界所有的语言统一成一套编码方案，这套编码方案就叫 Unicode，<strong>它为每种语言的每个字符设定了独一无二的二进制编码</strong>，这样就可以跨语言，跨平台进行文本处理了，是不是很棒！</p>
<p>Unicode 1.0 版诞生于 1991 年 10 月，至今它仍在不断增修，每个新版本都会加入更多新的字符，目前最新的版本为 2016 年 6 月 21 日公布的 9.0.0。</p>
<p>Unicode 标准使用十六进制数字，而且在数字前面加上前缀 U+，比如，大写字母「A」的 unicode 编码为 U+0041，汉字「严」的 unicode 编码为 U+4E25。更多的符号对应表，可以查询 unicode.org，或者专门的汉字对应表。</p>
</li>
<li><p>UTF-8</p>
<p>Unicode 看起来已经很完美了，实现了大一统。但是，Unicode 却存在一个很大的问题：资源浪费。</p>
<p>为什么这么说呢？原来，Unicode 为了能表示世界各国所有文字，一开始用两个字节，后来发现两个字节不够用，又用了四个字节。比如，汉字「严」的 unicode 编码是十六进制数 <code>4E25</code>，转换成二进制有十五位，即 100111000100101，因此至少需要两个字节才能表示这个汉字，但是对于其他的字符，就可能需要三个或四个字节，甚至更多。</p>
<p>这时，问题就来了，如果以前的 ASCII 字符集也用这种方式来表示，那岂不是很浪费存储空间。比如，大写字母「A」的二进制编码为 01000001，它只需要一个字节就够了，如果 unicode 统一使用三个字节或四个字节来表示字符，那「A」的二进制编码的前面几个字节就都是 <code>0</code>，这是很浪费存储空间的。</p>
<p>为了解决这个问题，在 Unicode 的基础上，人们实现了 UTF-16, UTF-32 和 UTF-8。下面只说一下 UTF-8。</p>
<p>UTF-8 (8-bit Unicode Transformation Format) 是一种针对 Unicode 的可变长度字符编码，它使用一到四个字节来表示字符，例如，ASCII 字符继续使用一个字节编码，阿拉伯文、希腊文等使用两个字节编码，常用汉字使用三个字节编码，等等。</p>
<p>因此，我们说，UTF-8 是 Unicode 的实现方式之一，其他实现方式还包括 UTF-16（字符用两个或四个字节表示）和 UTF-32（字符用四个字节表示）。</p>
</li>
</ul>
<h3 id="Python的默认编码"><a href="#Python的默认编码" class="headerlink" title="Python的默认编码"></a><strong>Python的默认编码</strong></h3><p>Python2 的默认编码是 ascii，Python3 的默认编码是 utf-8，可以通过下面的方式获取：</p>
<ul>
<li><p>Python2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Python 2.7.12 (default, Oct 11 2016, 05:20:59)</div><div class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] on darwin</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; sys.getdefaultencoding()</div><div class="line">&apos;ascii&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>Python3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Python 3.5.2 (default, Oct 11 2016, 04:59:56)</div><div class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] on darwin</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; sys.getdefaultencoding()</div><div class="line">&apos;utf-8&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Python3编码问题"><a href="#Python3编码问题" class="headerlink" title="Python3编码问题"></a><strong>Python3编码问题</strong></h3><p>Python3 最重要的一项改进之一就是解决了 Python2 中字符串与字符编码遗留下来的这个大坑。</p>
<p>Python2 字符串设计上的一些缺陷：</p>
<ul>
<li>使用 ASCII 码作为默认编码方式，对中文处理很不友好。 </li>
<li>把字符串的牵强地分为 unicode 和 str 两种类型，误导开发者</li>
</ul>
<p>首先，Python3 把系统默认编码设置为 UTF-8，然后，文本字符和二进制数据区分得更清晰，分别用 str 和 bytes 表示。文本字符全部用 str 类型表示，str 能表示 Unicode 字符集中所有字符，而二进制字节数据用一种全新的数据类型，用 bytes 来表示。</p>
<h4 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = "a"</div><div class="line">&gt;&gt;&gt; a</div><div class="line">'a'</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class 'str'&gt;</div><div class="line">&gt;&gt;&gt; b = "禅"</div><div class="line">&gt;&gt;&gt; b</div><div class="line">'禅'</div><div class="line">&gt;&gt;&gt; type(b)</div><div class="line">&lt;class 'str'&gt;</div></pre></td></tr></table></figure>
<h4 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a><strong>bytes</strong></h4><p>Python3 中，在字符引号前加‘b’，明确表示这是一个 bytes 类型的对象，实际上它就是一组二进制字节序列组成的数据，bytes 类型可以是 ASCII范围内的字符和其它十六进制形式的字符数据，但不能用中文等非ASCII字符表示。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = b'a'</div><div class="line">&gt;&gt;&gt; c</div><div class="line">b'a'</div><div class="line">&gt;&gt;&gt; type(c)</div><div class="line">&lt;class 'bytes'&gt;</div><div class="line">&gt;&gt;&gt; d = b'\xe7\xa6\x85'</div><div class="line">&gt;&gt;&gt; d</div><div class="line">b'\xe7\xa6\x85'</div><div class="line">&gt;&gt;&gt; type(d)</div><div class="line">&lt;class 'bytes'&gt;</div><div class="line">&gt;&gt;&gt; e = b'禅'</div><div class="line">  File "&lt;stdin&gt;", line 1</div><div class="line">SyntaxError: bytes can only contain ASCII literal characters.</div></pre></td></tr></table></figure>
<p>bytes 类型提供的操作和 str 一样，支持分片、索引、基本数值运算等操作。但是 str 与 bytes 类型的数据不能执行 <code>+</code> 操作，尽管在py2中是可行的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'a'</span>+<span class="string">b'c'</span></div><div class="line"><span class="string">b'ac'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'a'</span>*<span class="number">2</span></div><div class="line"><span class="string">b'aa'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b"abcdef\xd6"</span>[<span class="number">1</span>:]</div><div class="line"><span class="string">b'bcdef\xd6'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b"abcdef\xd6"</span>[<span class="number">-1</span>]</div><div class="line"><span class="number">214</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b"a"</span> + <span class="string">"b"</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: can<span class="string">'t concat bytes to str</span></div></pre></td></tr></table></figure>
<p>python2 与 python3 字节与字符的对应关系</p>
<table>
<thead>
<tr>
<th>python2</th>
<th>python3</th>
<th>表现</th>
<th>转换</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>str</td>
<td>bytes</td>
<td>字节</td>
<td>encode</td>
<td>存储</td>
</tr>
<tr>
<td>unicode</td>
<td>str</td>
<td>字符</td>
<td>decode</td>
<td>显示</td>
</tr>
</tbody>
</table>
<h4 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a><strong>encode与decode</strong></h4><p>str 与 bytes 之间的转换可以用 encode 和 decode 方法。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fejwfglr5uj316o0b4go4.jpg" alt=""></p>
<p>encode 负责字符到字节的编码转换。默认使用 UTF-8 编码转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Python之禅"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.encode()</div><div class="line"><span class="string">b'Python\xe4\xb9\x8b\xe7\xa6\x85'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.encode(<span class="string">'gbk'</span>)</div><div class="line"><span class="string">b'Python\xd6\xae\xec\xf8'</span></div></pre></td></tr></table></figure>
<p>decode 负责字节到字符的解码转换，通用使用 UTF-8 编码格式进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b&apos;Python\xe4\xb9\x8b\xe7\xa6\x85&apos;.decode()</div><div class="line">&apos;Python之禅&apos;</div><div class="line">&gt;&gt;&gt; b&apos;Python\xd6\xae\xec\xf8&apos;.decode(&quot;gbk&quot;)</div><div class="line">&apos;Python之禅&apos;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python字符编码&quot;&gt;&lt;a href=&quot;#Python字符编码&quot; class=&quot;headerlink&quot; title=&quot;Python字符编码&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python字符编码&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;字符编码是计算机编程中不可回避的问题，不管你用 Python2 还是 Python3，亦或是 C++, Java 等，我都觉得非常有必要理清计算机中的字符编码概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Unicode" scheme="http://yoursite.com/categories/Unicode/"/>
    
    
      <category term="Scrapy，Unicode，Python" scheme="http://yoursite.com/tags/Scrapy%EF%BC%8CUnicode%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>Python分布式爬虫打造搜索引擎项目学习笔记——Scrapy安装及调试</title>
    <link href="http://yoursite.com/2017/04/11/scrapy-install/"/>
    <id>http://yoursite.com/2017/04/11/scrapy-install/</id>
    <published>2017-04-11T12:18:54.000Z</published>
    <updated>2017-04-11T07:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkvirtualenv article_spider</div><div class="line">$ pip install -i https://pypi.douban.com/simple/ scrapy</div></pre></td></tr></table></figure>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ workon article_spider</div><div class="line">$ scrapy startproject ArticleSpider</div><div class="line">New Scrapy project &apos;ArticleSpider&apos;, using template directory &apos;/Users/lawtech/myvirtualenvs/article_spider/lib/python3.5/site-packages/scrapy/templates/project&apos;, created in:</div><div class="line">    /Users/lawtech/PycharmProjects/ArticleSpider</div><div class="line"></div><div class="line">You can start your first spider with:</div><div class="line">    cd ArticleSpider</div><div class="line">    scrapy genspider example example.com</div><div class="line">    </div><div class="line">$ cd ArticleSpider</div><div class="line">$ scrapy genspider jobbole blog.jobbole.com</div><div class="line">Created spider &apos;jobbole&apos; using template &apos;basic&apos; in module:</div><div class="line">  ArticleSpider.spiders.jobbole</div></pre></td></tr></table></figure>
<h2 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a><strong>项目目录介绍</strong></h2><p>首先先要回答一个问题。</p>
<p>问：把网站装进爬虫里，总共分几步？<br>答案很简单，四步：</p>
<ul>
<li>新建项目 (Project)：新建一个新的爬虫项目</li>
<li>明确目标（Items）：明确你想要抓取的目标</li>
<li>制作爬虫（Spider）：制作爬虫开始爬取网页</li>
<li>存储内容（Pipeline）：设计管道存储爬取内容</li>
</ul>
<p>创建好AticleSpider项目之后，可以看到将会创建一个AticleSpider文件夹，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ArticleSpider/  </div><div class="line">    scrapy.cfg  </div><div class="line">    ArticleSpider/  </div><div class="line">        __init__.py  </div><div class="line">        items.py  </div><div class="line">        pipelines.py  </div><div class="line">        settings.py  </div><div class="line">        spiders/  </div><div class="line">            __init__.py  </div><div class="line">            jobbole.py</div></pre></td></tr></table></figure>
<p>下面来简单介绍一下各个文件的作用：</p>
<ul>
<li>scrapy.cfg：项目的配置文件</li>
<li>ArticleSpider/：项目的 Python 模块，将会从这里引用代码</li>
<li>ArticleSpider/items.py：项目的 items 文件</li>
<li>ArticleSpider/pipelines.py：项目的 pipelines 文件</li>
<li>ArticleSpider/settings.py：项目的设置文件</li>
<li>ArticleSpider/spiders/：存储爬虫的目录</li>
</ul>
<h2 id="pycharm-调试-scrapy-执行流程"><a href="#pycharm-调试-scrapy-执行流程" class="headerlink" title="pycharm 调试 scrapy 执行流程"></a><strong>pycharm 调试 scrapy 执行流程</strong></h2><p>在项目根目录下新建 main.py 文件，添加如下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># __file__ 表示当前py文件</span></div><div class="line">sys.path.append(os.path.dirname(os.path.abspath(__file__)))</div><div class="line"><span class="comment"># 将实际命令拆分</span></div><div class="line">execute([<span class="string">"scrapy"</span>, <span class="string">"crawl"</span>, <span class="string">"spiders文件夹下的py文件名称"</span>])</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;环境搭建&lt;/strong&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://yoursite.com/categories/Scrapy/"/>
    
    
      <category term="Scrapy，Python" scheme="http://yoursite.com/tags/Scrapy%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>Python分布式爬虫打造搜索引擎项目学习笔记——爬虫基础知识回顾</title>
    <link href="http://yoursite.com/2017/04/11/scrapy-project-basic/"/>
    <id>http://yoursite.com/2017/04/11/scrapy-project-basic/</id>
    <published>2017-04-11T12:18:54.000Z</published>
    <updated>2017-04-11T07:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h2><h3 id="技术选型：scrapy-vs-requests-beautifulsoup"><a href="#技术选型：scrapy-vs-requests-beautifulsoup" class="headerlink" title="技术选型：scrapy vs requests + beautifulsoup"></a><strong>技术选型：<a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/" target="_blank" rel="external">scrapy</a> vs <a href="http://docs.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="external">requests</a> + <a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">beautifulsoup</a></strong></h3><a id="more"></a>
<ul>
<li>requests和beautifulsoup都是库，scrapy是框架</li>
<li>scrapy框架中可以加入requests和beautifulsoup</li>
<li>scrapy基于<a href="https://www.gitbook.com/book/likebeta/twisted-intro-cn/details" target="_blank" rel="external">twisted</a>，性能是最大的优势</li>
<li>scrapy方便扩展，提供了很多内置的功能</li>
<li>scrapy内置的css和xpath selector非常方便，beautifulsoup最大的缺点就是慢</li>
</ul>
<h3 id="网页分类"><a href="#网页分类" class="headerlink" title="网页分类"></a><strong>网页分类</strong></h3><ul>
<li>静态网页</li>
<li>动态网页</li>
<li>webservice（<a href="http://www.restapitutorial.com" target="_blank" rel="external">restapi</a>）</li>
</ul>
<h3 id="爬虫能做什么"><a href="#爬虫能做什么" class="headerlink" title="爬虫能做什么"></a><strong>爬虫能做什么</strong></h3><p>爬虫的作用</p>
<ul>
<li>搜索引擎——百度、谷歌、垂直领域搜索引擎</li>
<li>推荐引擎——今日头条</li>
<li>机器学习的数据样本</li>
<li>数据分析、舆情分析等</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h3><p>详见另一篇博客</p>
<h3 id="网站url结构"><a href="#网站url结构" class="headerlink" title="网站url结构"></a><strong>网站url结构</strong></h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1fehiknw0gbj315k0j0jth.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gy1fehikzuhq5j31300jo0v3.jpg" alt=""></p>
<h3 id="深度优先遍历和广度优先遍历"><a href="#深度优先遍历和广度优先遍历" class="headerlink" title="深度优先遍历和广度优先遍历"></a><strong>深度优先遍历和广度优先遍历</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></div><div class="line"><span class="string">"""</span></div><div class="line">__author__ = 'lawtech'</div><div class="line">__date__ = '2017/4/10 下午1:41'</div><div class="line">"""</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">深度优先遍历和广度优先遍历</div><div class="line">"""</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        self.node_neighbors = &#123;&#125;</div><div class="line">        self.visited = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_nodes</span><span class="params">(self, nodelist)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</div><div class="line">            self.add_node(node)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span><span class="params">(self, node)</span>:</span></div><div class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.nodes():</div><div class="line">            self.node_neighbors[node] = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span><span class="params">(self, edge)</span>:</span></div><div class="line">        u, v = edge</div><div class="line">        <span class="keyword">if</span> (v <span class="keyword">not</span> <span class="keyword">in</span> self.node_neighbors[u]) <span class="keyword">and</span> (u <span class="keyword">not</span> <span class="keyword">in</span> self.node_neighbors[v]):</div><div class="line">            self.node_neighbors[u].append(v)</div><div class="line">            <span class="keyword">if</span> u != v:</div><div class="line">                self.node_neighbors[v].append(u)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nodes</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.node_neighbors.keys()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth_first_search</span><span class="params">(self, root=None)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        队列</div><div class="line">        :param root: </div><div class="line">        :return: </div><div class="line">        """</div><div class="line">        order = []</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></div><div class="line">            self.visited[node] = <span class="keyword">True</span></div><div class="line">            order.append(node)</div><div class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> self.node_neighbors[node]:</div><div class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</div><div class="line">                    dfs(n)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> root:</div><div class="line">            dfs(root)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes():</div><div class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</div><div class="line">                dfs(node)</div><div class="line"></div><div class="line">        print(order)</div><div class="line">        <span class="keyword">return</span> order</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breadth_first_search</span><span class="params">(self, root=None)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        递归</div><div class="line">        :param root: </div><div class="line">        :return: </div><div class="line">        """</div><div class="line">        queue = []</div><div class="line">        order = []</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</div><div class="line">                node = queue.pop(<span class="number">0</span>)</div><div class="line">                self.visited[node] = <span class="keyword">True</span></div><div class="line"></div><div class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> self.node_neighbors[node]:</div><div class="line">                    <span class="keyword">if</span> (n <span class="keyword">not</span> <span class="keyword">in</span> self.visited) <span class="keyword">and</span> (n <span class="keyword">not</span> <span class="keyword">in</span> queue):</div><div class="line">                        queue.append(n)</div><div class="line">                        order.append(n)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> root:</div><div class="line">            queue.append(root)</div><div class="line">            order.append(root)</div><div class="line">            bfs()</div><div class="line"></div><div class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes():</div><div class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</div><div class="line">                queue.append(node)</div><div class="line">                order.append(node)</div><div class="line">                bfs()</div><div class="line"></div><div class="line">        print(order)</div><div class="line">        <span class="keyword">return</span> order</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    g = Graph()</div><div class="line">    g.add_nodes(nodelist=[i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)])</div><div class="line">    g.add_edge((<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">    g.add_edge((<span class="number">1</span>, <span class="number">3</span>))</div><div class="line">    g.add_edge((<span class="number">2</span>, <span class="number">4</span>))</div><div class="line">    g.add_edge((<span class="number">2</span>, <span class="number">5</span>))</div><div class="line">    g.add_edge((<span class="number">4</span>, <span class="number">8</span>))</div><div class="line">    g.add_edge((<span class="number">5</span>, <span class="number">8</span>))</div><div class="line">    g.add_edge((<span class="number">3</span>, <span class="number">6</span>))</div><div class="line">    g.add_edge((<span class="number">3</span>, <span class="number">7</span>))</div><div class="line">    g.add_edge((<span class="number">6</span>, <span class="number">7</span>))</div><div class="line">    print(<span class="string">"nodes:"</span>, g.nodes())</div><div class="line"></div><div class="line">    g.breadth_first_search(<span class="number">1</span>)</div><div class="line">    g.depth_first_search(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>​    (‘nodes:’, [1, 2, 3, 4, 5, 6, 7, 8])</p>
<p>​    [1, 2, 3, 4, 5, 6, 7, 8]</p>
<p>​    [1, 2, 4, 8, 5, 3, 6, 7]</p>
<h3 id="爬虫去重策略"><a href="#爬虫去重策略" class="headerlink" title="爬虫去重策略"></a><strong>爬虫去重策略</strong></h3><ul>
<li>将访问过的url保存到数据库中</li>
<li>将访问过的url保存到set中，只需要O(1)的代价就可以查询url</li>
<li>url经过md5等方法哈希后保存到set中</li>
<li>用bitmap方法，将访问过的url通过hash函数映射到某一位</li>
<li>bloomfilter方法对bitmap进行改进，多重hash函数降低冲突</li>
</ul>
<h3 id="Python字符串编码"><a href="#Python字符串编码" class="headerlink" title="Python字符串编码"></a><strong>Python字符串编码</strong></h3><p>详见另一篇博客</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础知识&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;技术选型：scrapy-vs-requests-beautifulsoup&quot;&gt;&lt;a href=&quot;#技术选型：scrapy-vs-requests-beautifulsoup&quot; class=&quot;headerlink&quot; title=&quot;技术选型：scrapy vs requests + beautifulsoup&quot;&gt;&lt;/a&gt;&lt;strong&gt;技术选型：&lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/1.0/&quot;&gt;scrapy&lt;/a&gt; vs &lt;a href=&quot;http://docs.python-requests.org/zh_CN/latest/index.html&quot;&gt;requests&lt;/a&gt; + &lt;a href=&quot;http://beautifulsoup.readthedocs.io/zh_CN/latest/&quot;&gt;beautifulsoup&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
    
    </summary>
    
      <category term="Basic knowledge" scheme="http://yoursite.com/categories/Basic-knowledge/"/>
    
    
      <category term="Scrapy，Python" scheme="http://yoursite.com/tags/Scrapy%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>Python分布式爬虫打造搜索引擎项目学习笔记——Xpath用法</title>
    <link href="http://yoursite.com/2017/04/11/xpath-usage/"/>
    <id>http://yoursite.com/2017/04/11/xpath-usage/</id>
    <published>2017-04-11T12:18:54.000Z</published>
    <updated>2017-04-11T08:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XPath的用法"><a href="#XPath的用法" class="headerlink" title="XPath的用法"></a><strong>XPath的用法</strong></h2><h3 id="XPath简介"><a href="#XPath简介" class="headerlink" title="XPath简介"></a><strong>XPath简介</strong></h3><ul>
<li>XPath 使用路径表达式在 XML / HTML 文档中进行导航</li>
<li>XPath 包含一个标准函数库</li>
<li>XPath 是 XSLT 中的主要元素</li>
<li>XPath 是一个 W3C 标准</li>
</ul>
<a id="more"></a>
<h3 id="XPath术语"><a href="#XPath术语" class="headerlink" title="XPath术语"></a><strong>XPath术语</strong></h3><h4 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a><strong>节点（Node）</strong></h4><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。</p>
<p>请看下面这个 XML 文档：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的XML文档中的节点例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span> （文档节点）</div><div class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> （元素节点）</div><div class="line">lang="en" （属性节点）</div></pre></td></tr></table></figure>
<h4 id="基本值（或称原子值，Atomic-value）"><a href="#基本值（或称原子值，Atomic-value）" class="headerlink" title="基本值（或称原子值，Atomic value）"></a><strong>基本值（或称原子值，Atomic value）</strong></h4><p>基本值是无父或无子的节点。</p>
<p>基本值的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">J K. Rowling</div><div class="line">"en"</div></pre></td></tr></table></figure>
<h4 id="项目（Item）"><a href="#项目（Item）" class="headerlink" title="项目（Item）"></a><strong>项目（Item）</strong></h4><p>项目是基本值或者节点。</p>
<h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a><strong>节点关系</strong></h4><p>参考示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>父节点（Parent）</p>
<p>每个元素以及属性都有一个父节点。</p>
<p>在上面的例子中，book 元素是 title、author、year 以及 price 元素的父节点</p>
</li>
<li><p>子节点（Children）</p>
<p>元素节点可有零个、一个或多个子节点。</p>
<p>在上面的例子中，title、author、year 以及 price 元素都是 book 元素的子节点</p>
</li>
<li><p>同胞节点（Sibling）</p>
<p>拥有相同的父节点的节点</p>
<p>在上面的例子中，title、author、year 以及 price 元素都是同胞节点</p>
</li>
<li><p>先辈节点（Ancestor）</p>
<p>某节点的父节点、父节点的父节点，等等。</p>
<p>在上面的例子中，title 元素的先辈节点是 book 元素和 bookstore 元素</p>
</li>
<li><p>后代节点（Descendant）</p>
<p>某个节点的子节点，子节点的子节点，等等。</p>
<p>在上面的例子中，bookstore 的后代节点是 book、title、author、year 以及 price 元素</p>
</li>
</ul>
<h3 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a><strong>XPath语法</strong></h3><p>参考示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"eng"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"eng"</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a><strong>选取节点</strong></h4><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。下面列出了最有用的路径表达式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nodename</td>
<td style="text-align:left">选取此节点的所有子节点</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">从根节点选取</td>
</tr>
<tr>
<td style="text-align:left">//</td>
<td style="text-align:left">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">选取当前节点</td>
</tr>
<tr>
<td style="text-align:left">..</td>
<td style="text-align:left">选取当前节点的父节点。</td>
</tr>
<tr>
<td style="text-align:left">@</td>
<td style="text-align:left">选取属性。</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">路径表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bookstore</td>
<td style="text-align:left">选取bookstore元素的所有子节点</td>
</tr>
<tr>
<td style="text-align:left">/bookstore</td>
<td style="text-align:left">选取根元素bookstore 注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>
</tr>
<tr>
<td style="text-align:left">bookstore/book</td>
<td style="text-align:left">选取属于bookstore的子元素的所有book元素</td>
</tr>
<tr>
<td style="text-align:left">//book</td>
<td style="text-align:left">选取所有book元素，而不考虑它们的位置</td>
</tr>
<tr>
<td style="text-align:left">bookstore//book</td>
<td style="text-align:left">选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置</td>
</tr>
<tr>
<td style="text-align:left">//@lang</td>
<td style="text-align:left">选取名为 lang 的所有属性</td>
</tr>
</tbody>
</table>
<h4 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a><strong>谓语（Predicates）</strong></h4><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p>
<p>谓语被嵌在方括号中。</p>
<p>实例</p>
<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>
<table>
<thead>
<tr>
<th style="text-align:left">路径表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/bookstore/book[1]</td>
<td style="text-align:left">选取属于 bookstore 子元素的第一个 book 元素</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[last()]</td>
<td style="text-align:left">选取属于 bookstore 子元素的最后一个 book 元素</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[last()-1]</td>
<td style="text-align:left">选取属于 bookstore 子元素的倒数第二个 book 元素</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[postion()&lt;3]</td>
<td style="text-align:left">选取最前面的两个属于 bookstore 元素的子元素的 book 元素</td>
</tr>
<tr>
<td style="text-align:left">//title[@lang]</td>
<td style="text-align:left">选取所有拥有名为 lang 的属性的 title 元素</td>
</tr>
<tr>
<td style="text-align:left">//title[@lang=’eng’]</td>
<td style="text-align:left">选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[price&gt;35.00]</td>
<td style="text-align:left">选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00</td>
</tr>
<tr>
<td style="text-align:left">/bookstore/book[price&gt;35.00]/title</td>
<td style="text-align:left">选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00</td>
</tr>
</tbody>
</table>
<h4 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a><strong>选取未知节点</strong></h4><p>XPath 通配符可用来选取未知的 XML 元素</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何元素节点</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点</td>
</tr>
<tr>
<td>node()</td>
<td>匹配任何节点</td>
</tr>
</tbody>
</table>
<p>实例</p>
<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bookstore/*</td>
<td>选取 bookstore 元素的所有子元素</td>
</tr>
<tr>
<td>//*</td>
<td>选取文档中的所有元素</td>
</tr>
<tr>
<td>//title[@*]</td>
<td>选取所有带有属性的 title 元素</td>
</tr>
</tbody>
</table>
<h4 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a><strong>选取若干路径</strong></h4><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>
<p>实例</p>
<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>//book/title &#124; //book/price</td>
<td>选取 book 元素的所有 title 和 price 元素</td>
</tr>
<tr>
<td>//title &#124; //price</td>
<td>选取文档中的所有 title 和 price 元素</td>
</tr>
<tr>
<td>/bookstore/book/title &#124; //price</td>
<td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XPath的用法&quot;&gt;&lt;a href=&quot;#XPath的用法&quot; class=&quot;headerlink&quot; title=&quot;XPath的用法&quot;&gt;&lt;/a&gt;&lt;strong&gt;XPath的用法&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;XPath简介&quot;&gt;&lt;a href=&quot;#XPath简介&quot; class=&quot;headerlink&quot; title=&quot;XPath简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;XPath简介&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;XPath 使用路径表达式在 XML / HTML 文档中进行导航&lt;/li&gt;
&lt;li&gt;XPath 包含一个标准函数库&lt;/li&gt;
&lt;li&gt;XPath 是 XSLT 中的主要元素&lt;/li&gt;
&lt;li&gt;XPath 是一个 W3C 标准&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="XPath" scheme="http://yoursite.com/categories/XPath/"/>
    
    
      <category term="Scrapy，XPath，Python" scheme="http://yoursite.com/tags/Scrapy%EF%BC%8CXPath%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>Python分布式爬虫打造搜索引擎项目学习笔记——Python正则表达式</title>
    <link href="http://yoursite.com/2017/04/11/regex/"/>
    <id>http://yoursite.com/2017/04/11/regex/</id>
    <published>2017-04-11T12:18:54.000Z</published>
    <updated>2017-04-11T12:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python正则表达式"><a href="#Python正则表达式" class="headerlink" title="Python正则表达式"></a><strong>Python正则表达式</strong></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p>
<p>Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。</p>
<p>re 模块使 Python 语言拥有全部的正则表达式功能。<br><a id="more"></a></p>
<p>compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</p>
<p>re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p>
<h3 id="正则表达式模式（常用）"><a href="#正则表达式模式（常用）" class="headerlink" title="正则表达式模式（常用）"></a><strong>正则表达式模式（常用）</strong></h3><p>模式字符串使用特殊的语法来表示一个正则表达式：字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。多数字母和数字前加一个反斜杠时会拥有不同的含义。标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。反斜杠本身需要使用反斜杠转义。由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’/t’，等价于’//t’)匹配相应的特殊字符。</p>
<p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的末尾</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符，除了换行符”\n”，当re.DOTALL标记被指定时，可以匹配包含换行符的任意字符</td>
</tr>
<tr>
<td>[…]</td>
<td>用来表示一组字符，单独列出：[amk]匹配’a’，’m’或’k’</td>
</tr>
<tr>
<td>[^…]</td>
<td>不在[]中的字符： [ ^abc ]匹配除了a,b,c之外的字符</td>
</tr>
<tr>
<td>re*</td>
<td>匹配0个或多个的表达式</td>
</tr>
<tr>
<td>re+</td>
<td>匹配1个或多个的表达式</td>
</tr>
<tr>
<td>re?</td>
<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td>re{ n,}</td>
<td>精确匹配n个前面表达式</td>
</tr>
<tr>
<td>re{n,m}</td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>a &#124; b</td>
<td>匹配a或b</td>
</tr>
<tr>
<td>(re)</td>
<td>匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td>(?imx)</td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域</td>
</tr>
<tr>
<td>(?-imx)</td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母数字及下划线</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母数字及下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白字符，等价于 [\t\n\r\f].</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字，等价于 [0-9].</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字</td>
</tr>
<tr>
<td>\A</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串</td>
</tr>
<tr>
<td>\z</td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td>\G</td>
<td>匹配最后匹配完成的位置</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’</td>
</tr>
<tr>
<td>\n,\t,等</td>
<td>匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td>\1…\9</td>
<td>匹配第n个分组的子表达式。</td>
</tr>
<tr>
<td>\10</td>
<td>匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式</td>
</tr>
</tbody>
</table>
<h3 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a><strong>正则表达式实例</strong></h3><p>字符匹配</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>python</td>
<td>匹配”python”</td>
</tr>
</tbody>
</table>
<p>字符类</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Pp]ython</td>
<td>匹配 “Python” 或 “python”</td>
</tr>
<tr>
<td>rub[ye]</td>
<td>匹配 “ruby” 或 “rube”</td>
</tr>
<tr>
<td>[lawtech]</td>
<td>匹配中括号内的任意一个字母</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配任何数字。类似于 [0123456789]</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配任何小写字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配任何大写字母</td>
</tr>
<tr>
<td>[a-zA-Z0-9]</td>
<td>匹配任何字母及数字</td>
</tr>
<tr>
<td>[^lawtech]</td>
<td>除了lawtech字母以外的所有字符</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配除了数字外的字符</td>
</tr>
</tbody>
</table>
<p>特殊字符类</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除 “\n” 之外的任何单个字符，要匹配包括 ‘\n’ 在内的任何字符，请使用像’[.\n]’ 的模式</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符，等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符，等价于 [ ^0-9 ]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等，等价于[\f\n\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [ ^\f\n\r\t\v ]</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符，等价于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符等价于 [ ^A-Za-z0-9_ ]</td>
</tr>
</tbody>
</table>
<h3 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符 - 可选标志"></a>正则表达式修饰符 - 可选标志</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th style="text-align:left">描述</th>
<th>全拼</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I</td>
<td style="text-align:left">使匹配对大小写不敏感</td>
<td>IGNORECASE</td>
</tr>
<tr>
<td>re.L</td>
<td style="text-align:left">做本地化识别（locale-aware）匹配</td>
<td>LOCALE</td>
</tr>
<tr>
<td>re.M</td>
<td style="text-align:left">多行匹配，影响 ^ 和 $</td>
<td>MULTILINE</td>
</tr>
<tr>
<td>re.S</td>
<td style="text-align:left">使 . 匹配包括换行在内的所有字符</td>
<td>DOTALL</td>
</tr>
<tr>
<td>re.U</td>
<td style="text-align:left">根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td>
<td>UNICODE</td>
</tr>
<tr>
<td>re.X</td>
<td style="text-align:left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td>
<td>VERBOSE</td>
</tr>
</tbody>
</table>
<h3 id="re模块能够处理正则表达式的操作生成正则表达式对象"><a href="#re模块能够处理正则表达式的操作生成正则表达式对象" class="headerlink" title="re模块能够处理正则表达式的操作生成正则表达式对象"></a><strong>re模块能够处理正则表达式的操作生成正则表达式对象</strong></h3><ul>
<li><p>生成正则表达式对象 compile(pattern, flags=0)构建一个正则表达式，返回该正则表达式对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">pattern = re.compile(<span class="string">'re'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>进行匹配</p>
<ul>
<li>match() 确定正则表达式是否匹配字符串的开头</li>
<li>search() 扫描字符串以查找匹配</li>
<li>findall() 找到所有正则表达式匹配的子字符串，并把它们作为一个列表返回</li>
<li>finditer() 找到所有正则表达式匹配的子字符串，并把它们以迭代器的形式返回</li>
<li>group() 返回通过正则表达式匹配到的字符串</li>
<li>start() 返回成功匹配开始位置</li>
<li>end()   返回成功匹配结束位置</li>
<li>span()  返回包含成功匹配开始和结束位置的元组</li>
</ul>
</li>
</ul>
<h4 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a><strong>re.match函数</strong></h4><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None。</p>
<p>函数语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.match(pattern, string, flags=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>函数参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</td>
</tr>
</tbody>
</table>
<p>匹配成功re.match方法返回一个匹配的对象（match object），否则返回None。</p>
<p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th>匹配对象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(num=0)</td>
<td>匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组</td>
</tr>
<tr>
<td>groups()</td>
<td>返回一个包含所有小组字符串的元组，从1到所含的小组号</td>
</tr>
</tbody>
</table>
<p>实例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">print(re.match(<span class="string">'www'</span>, <span class="string">'www.lawtech0902.com'</span>).span())  <span class="comment"># 在起始位置匹配</span></div><div class="line">print(re.match(<span class="string">'com'</span>, <span class="string">'www.lawtech0902.com'</span>)) <span class="comment"># 不在起始位置匹配</span></div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">line = <span class="string">"Cats are smarter than dogs"</span></div><div class="line"></div><div class="line">matchObj = re.match( <span class="string">r'(.*) are (.*?) .*'</span>, line, re.M|re.I)</div><div class="line"></div><div class="line"><span class="keyword">if</span> matchObj:</div><div class="line">   print(<span class="string">"matchObj.group() : "</span>, matchObj.group())</div><div class="line">   print(<span class="string">"matchObj.group(1) : "</span>, matchObj.group(<span class="number">1</span>))</div><div class="line">   print(<span class="string">"matchObj.group(2) : "</span>, matchObj.group(<span class="number">2</span>))</div><div class="line"><span class="keyword">else</span>:</div><div class="line">   print(<span class="string">"No match!!"</span>)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">matchObj.group() :  Cats are smarter than dogs</div><div class="line">matchObj.group(<span class="number">1</span>) :  Cats</div><div class="line">matchObj.group(<span class="number">2</span>) :  smarter</div></pre></td></tr></table></figure>
<h4 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a><strong>re.search方法</strong></h4><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p>函数语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.search(pattern, string, flags=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>函数参数说明与re.match方法相同。</p>
<p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p>
<p>实例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">print(re.search(<span class="string">'www'</span>, <span class="string">'www.lawtech0902.com'</span>).span())  <span class="comment"># 在起始位置匹配</span></div><div class="line">print(re.search(<span class="string">'com'</span>, <span class="string">'www.lawtech0902.com'</span>).span())  <span class="comment"># 不在起始位置匹配</span></div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line">(<span class="number">16</span>, <span class="number">19</span>)</div></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">line = <span class="string">"Cats are smarter than dogs"</span></div><div class="line"></div><div class="line">searchObj = re.search( <span class="string">r'(.*) are (.*?) .*'</span>, line, re.M|re.I)</div><div class="line"></div><div class="line"><span class="keyword">if</span> searchObj:</div><div class="line">   print(<span class="string">"searchObj.group() : "</span>, searchObj.group())</div><div class="line">   print(<span class="string">"searchObj.group(1) : "</span>, searchObj.group(<span class="number">1</span>))</div><div class="line">   print(<span class="string">"searchObj.group(2) : "</span>, searchObj.group(<span class="number">2</span>))</div><div class="line"><span class="keyword">else</span>:</div><div class="line">   print(<span class="string">"Nothing found!!"</span>)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">searchObj.group() :  Cats are smarter than dogs</div><div class="line">searchObj.group(<span class="number">1</span>) :  Cats</div><div class="line">searchObj.group(<span class="number">2</span>) :  smarter</div></pre></td></tr></table></figure>
<h4 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h4><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">line = <span class="string">"Cats are smarter than dogs"</span></div><div class="line"></div><div class="line">matchObj = re.match( <span class="string">r'dogs'</span>, line, re.M|re.I)</div><div class="line"><span class="keyword">if</span> matchObj:</div><div class="line">   print(<span class="string">"match --&gt; matchObj.group() : "</span>, matchObj.group())</div><div class="line"><span class="keyword">else</span>:</div><div class="line">   print(<span class="string">"No match!!"</span>)</div><div class="line"></div><div class="line">matchObj = re.search( <span class="string">r'dogs'</span>, line, re.M|re.I)</div><div class="line"><span class="keyword">if</span> matchObj:</div><div class="line">   print(<span class="string">"search --&gt; matchObj.group() : "</span>, matchObj.group())</div><div class="line"><span class="keyword">else</span>:</div><div class="line">   print(<span class="string">"No match!!"</span>)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">No match!!</div><div class="line">search --&gt; matchObj.group() :  dogs</div></pre></td></tr></table></figure>
<h4 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a><strong>检索和替换</strong></h4><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
</ul>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">phone = <span class="string">"2004-959-559 # 这是一个国外电话号码"</span></div><div class="line"></div><div class="line"><span class="comment"># 删除字符串中的 Python注释 </span></div><div class="line">num = re.sub(<span class="string">r'#.*$'</span>, <span class="string">""</span>, phone)</div><div class="line">print(<span class="string">"电话号码是: "</span>, num)</div><div class="line"></div><div class="line"><span class="comment"># 删除非数字(-)的字符串 </span></div><div class="line">num = re.sub(<span class="string">r'\D'</span>, <span class="string">""</span>, phone)</div><div class="line">print(<span class="string">"电话号码是 : "</span>, num)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">电话号码是:  <span class="number">2004</span><span class="number">-959</span><span class="number">-559</span></div><div class="line">电话号码是 :  <span class="number">2004959559</span></div></pre></td></tr></table></figure>
<h5 id="repl参数是一个函数"><a href="#repl参数是一个函数" class="headerlink" title="repl参数是一个函数"></a><strong>repl参数是一个函数</strong></h5><p>以下实例中将字符串中的匹配的数字乘于 2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 将匹配的数字乘于 2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(matched)</span>:</span></div><div class="line">    value = int(matched.group(<span class="string">'value'</span>))</div><div class="line">    <span class="keyword">return</span> str(value * <span class="number">2</span>)</div><div class="line"></div><div class="line">s = <span class="string">'A23G4HFD567'</span></div><div class="line">print(re.sub(<span class="string">'(?P&lt;value&gt;\d+)'</span>, double, s))</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A46G8HFD1134</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python正则表达式&quot;&gt;&lt;a href=&quot;#Python正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python正则表达式&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python正则表达式&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。&lt;/p&gt;
&lt;p&gt;Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。&lt;/p&gt;
&lt;p&gt;re 模块使 Python 语言拥有全部的正则表达式功能。&lt;br&gt;
    
    </summary>
    
      <category term="Regular Expression" scheme="http://yoursite.com/categories/Regular-Expression/"/>
    
    
      <category term="Scrapy，Regular Expression，Python" scheme="http://yoursite.com/tags/Scrapy%EF%BC%8CRegular-Expression%EF%BC%8CPython/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记(五)：数据安全与性能保障——复制</title>
    <link href="http://yoursite.com/2017/04/10/Redis-5/"/>
    <id>http://yoursite.com/2017/04/10/Redis-5/</id>
    <published>2017-04-10T12:18:54.000Z</published>
    <updated>2017-04-12T06:16:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>复制（replication），可以让其他服务器拥有一个不断更新的数据副本，从而使得拥有数据副本的服务器可以用于处理客户端发送的读请求。对于高负载应用来说，复制是不可或缺的一个特性。</p>
<a id="more"></a>
<p>关系型数据库通常会使用一个主服务器（master）向多个从服务器（slave）发送更新，并使用从服务器来处理所有读请求。Redis也采用了同样的方法来实现自己的复制特性，并将其用作扩展性能的一种手段。</p>
<h2 id="复制相关配置选项"><a href="#复制相关配置选项" class="headerlink" title="复制相关配置选项"></a><strong>复制相关配置选项</strong></h2><p>当从服务器连接主服务器时，主服务器会执行BGSAVE操作，为了正确地使用复制特性，用户需要保证服务器已经正确地设置了dir选项和dirname选项。</p>
<p>配置<code>slaveof host port</code>选项即可连接主服务器。</p>
<p>下面将演示怎么实现一个简单的复制系统。我们在一台机器上起两个Redis实例，监听不同的端口，其中一个作为主库，另外一个作为从库。首先不加任何参数来启动一个Redis实例作为主数据库：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1fej0vywpikj30wi0p4why.jpg" alt=""></p>
<p>主库默认监听6379端口。</p>
<p>接着新建一个终端，加上slaveof参数启动另一个Redis实例作为从库，并且监听6380端口：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1fej0wwdiejj30wi0p4n0t.jpg" alt=""></p>
<p>从控制台输出中可以看到，从库已经连接到主库：126.0.0.1:6379了，我们可以分别在主库和从库中使用<code>info replication</code>命令看一看当前实例在复制系统中的相关信息</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1fej0y3xp1fj30wi0vqwk6.jpg" alt=""></p>
<p>现在可以测试一下主从库的数据同步了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 6379</div><div class="line">127.0.0.1:6379&gt; set test-replicate lawtech</div><div class="line">OK</div><div class="line">$ redis-cli -p 6380</div><div class="line">127.0.0.1:6380&gt; get test-replicate</div><div class="line">&quot;lawtech&quot;</div><div class="line">127.0.0.1:6380&gt; set x y</div><div class="line">(error) READONLY You can&apos;t write against a read only slave.</div></pre></td></tr></table></figure>
<p>可以看到，在主库中添加的数据确实同步到了从库中。但是，我们在向从库中写入数据时报错了，这是因为在默认情况下，从库是只读的。我们可以在从库的配置文件中加上如下的配置项允许从库写数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slave-read-only no</div></pre></td></tr></table></figure>
<p>但是，因为从库中修改的数据不会被同步到任何其他数据库，并且一旦主库修改了数据，从库的数据就会因为自动同步被覆盖，所以一般情况下，不建议将从库设置为可写。</p>
<p>相同的道理，配置多台从库也使用相同的方法，都在从库的配置文件中加上slaveof参数即可。</p>
<p>此外，我们可以在客户端使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SLAVEOF 新主库地址  新主库端口</div></pre></td></tr></table></figure>
<p>来修改当前数据库的主库，如果当前数据库已经是其他库的从库， 则当前数据库会停止和原来的数据库的同步而和新的数据库同步。</p>
<p>最后，从数据库还可以通过运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SLAVEOF NO ONE</div></pre></td></tr></table></figure>
<p>来停止接受来自其他数据库的同步而升级成为主库。</p>
<h2 id="Redis复制的启动过程"><a href="#Redis复制的启动过程" class="headerlink" title="Redis复制的启动过程"></a>Redis复制的启动过程</h2><p>从服务器连接主服务器时，主服务器会创建一个快照文件并将其发送至从服务器，但这只是主从复制执行过程的其中一步，下表列举出复制过程主从服务器执行的所有操作：</p>
<table>
<thead>
<tr>
<th style="text-align:center">步骤</th>
<th style="text-align:center">主服务器操作</th>
<th style="text-align:center">从服务器操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">（ 等待命令进入）</td>
<td style="text-align:center">连接(或者重连接)主服务器，发送SYNC命令</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令</td>
<td style="text-align:center">根据配置选项来决定时继续使用现在的数据来处理客户端命令，还是向发送请求的客户端返回错误</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">BGSAVE执行完毕，向从服务器发送快照文件，并在发送期间继续使用缓冲区记录被执行的写命令</td>
<td style="text-align:center">丢弃所有旧的数据，开始载入主服务器发来的快照文件</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令</td>
<td style="text-align:center">完成对快照文件的解释操作，像往常一样开始接受命令请求</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">缓冲区存储的写命令发送完毕；从现在开始，没执行一个写命令，就像从服务器发送相同的写命令</td>
<td style="text-align:center">执行主服务器发来的所有存储在缓冲区里面的写命令；从现在开始，接收并执行主服务器传来的每个写命令</td>
</tr>
</tbody>
</table>
<p>由上述步骤可以看出，有必要给Redis主服务器留30%~45%的内存用于执行BGSAVE命令和创建记录写命令的缓冲区。另外，从服务器还有一点需要注意的是，从服务器在进行同步时，会清空自己的所有数据，因为第3步中，从服务器会丢弃所有旧数据。</p>
<p>警告：Redis不支持主主复制（master-master replication）</p>
<p>当多个从服务器尝试连接同一个主服务器的时候，就会出现下表所示的两种情况中的其中一种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">当有新的从服务器连接主服务器时</th>
<th style="text-align:center">主服务器的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上述步骤3尚未执行</td>
<td style="text-align:center">所有从服务器都会接收相同的快照文件和相同的缓冲区写命令</td>
</tr>
<tr>
<td style="text-align:center">上述步骤3正在执行或者已经执行</td>
<td style="text-align:center">当主服务器与较早进行连接的从服务器执行完复制所需的5个步骤之后，主服务器会与新连接的从服务器执行一次新的步骤1至步骤5</td>
</tr>
</tbody>
</table>
<p>由此可以看出多个从服务器的同步对网络的开销挺大的，有可能会影响到主服务器接收写命令，甚至是与主服务器位于同一网络中的其他硬件。</p>
<h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a><strong>主从链</strong></h2><p>创建多个从服务器可能造成网络不可用，此时可以使用另外一个解决方案，从服务器拥有自己的从服务器，并由此形成主从链（master/slave chaining）。</p>
<p>从服务器对从服务器进行复制在操作上和从服务器对主服务器进行复制的唯一区别在于。如果从服务器X拥有从服务器Y，那么当从服务器X在执行启动过程表中步骤4时，X将断开与Y的连接，导致Y需要重新连接并重新同步（resync）。</p>
<p>当读请求的重要性明显高于写请求的重要性，并且读请求的数量需求远远超出一台Redis服务器可以处理的范围时，用户就需要添加新的从服务器来处理读请求，随着负载不断上升，主服务器可能会无法快速地更新所有从服务器。</p>
<p>为了缓解这个问题，可以创建一个由Redis主/从节点(master/slave node)组成的中间层来分担主服务器的复制工作，如下图所示：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fej1jof0f1j312s0cwgou.jpg" alt=""></p>
<p>上面这个示例中，树的中层有3个帮助开展复制工作的服务器，底层有9个从服务器。其中，只有3台从服务器和主服务器通信，其他都向从服务器同步数据，从而降低了系统的负载。</p>
<h2 id="检验硬盘写入"><a href="#检验硬盘写入" class="headerlink" title="检验硬盘写入"></a><strong>检验硬盘写入</strong></h2><p>为了将数据保存在多台机器中，用户首先需要为主服务器设置多个从服务器，然后对每个从服务器设置<code>appendonly yes</code>选项和<code>appendfsync everysec</code>选项（如有需要，也可以对主服务器这样设置），但这只是第一步：因为用户还需要等待主服务器发送的写命令到达从服务器，并且在执行后续操作前，检查数据是否已经被写入了硬盘中。</p>
<p>整个操作分两个环节：</p>
<ul>
<li>验证主服务器是否已经将写数据发送至从服务器：用户需要在向主服务器写入真正的数据之后，再向主服务器写入一个唯一的虚构值（unique dummy value），然后通过检查虚构值是否存在于从服务器来判断数据是否已经到达从服务器。</li>
<li>判断数据是否已经被保存到硬盘中：检查INFO命令的输出结果中<code>aof_pending_bio_fsync</code>属性的值是否为0，如果是，则数据已经被保存到了硬盘中。</li>
</ul>
<p>在向主服务器写入数据后，用户可以将主服务器和从服务器的连接作为参数调用下面的代码来自动进行上述操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></div><div class="line"><span class="keyword">import</span> uuid</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_sync</span><span class="params">(mconn, sconn)</span>:</span></div><div class="line">    identifier = str(uuid.uuid4())</div><div class="line">    <span class="comment"># 将令牌添加至主服务器</span></div><div class="line">    mconn.zadd(<span class="string">'sync:wait'</span>, identifier, time.time())</div><div class="line">    </div><div class="line">    <span class="comment"># 如果有必要的话，等待从服务器完成同步</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> sconn.info()[<span class="string">'master_link_status'</span>] != <span class="string">'up'</span>:</div><div class="line">        time.sleep(<span class="number">.001</span>)</div><div class="line">        </div><div class="line">    <span class="comment"># 等待从服务器接收数据更新</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> sconn.zscore(<span class="string">'sync:wait'</span>, identifier):</div><div class="line">        time.sleep(<span class="number">.001</span>)</div><div class="line">        </div><div class="line">    <span class="comment"># 最多只等待1秒</span></div><div class="line">    deadline = time.time() + <span class="number">1.01</span></div><div class="line">    </div><div class="line">    <span class="comment"># 检查数据更新是否已经被同步到了硬盘</span></div><div class="line">    <span class="keyword">while</span> time.time() &lt; deadline:</div><div class="line">        <span class="keyword">if</span> sconn.info()[<span class="string">'aof_pending_bio_fsync'</span>] == <span class="number">0</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        time.sleep(<span class="number">.001</span>)</div><div class="line">        </div><div class="line">    <span class="comment"># 清理刚刚创建的新令牌以及之前可能留下的旧令牌</span></div><div class="line">    mconn.zrem(<span class="string">'sync:wait'</span>, identifier)</div><div class="line">    mconn.zremrangebyscore(<span class="string">'sync:wait'</span>, <span class="number">0</span>, time.time() - <span class="number">900</span>)</div></pre></td></tr></table></figure>
<p>为了确保操作可以正确执行，wait_for_sync()函数会首先确认从服务器已经连接上主服务器，然后检查自己添加到等待同步有序集合（sync wait ZSET）里面的值是否已经存在于从服务器，在发现值存在后，等待从服务器将缓冲区的所有数据写入硬盘里。最后，确认数据已经被保存到硬盘之后，函数会执行一些清理操作。</p>
<p>通过同时使用复制和AOF持久化，用户可以增强Redis对于系统崩溃的抵抗能力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复制（replication），可以让其他服务器拥有一个不断更新的数据副本，从而使得拥有数据副本的服务器可以用于处理客户端发送的读请求。对于高负载应用来说，复制是不可或缺的一个特性。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis, Python" scheme="http://yoursite.com/tags/Redis-Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记(四)：数据安全与性能保障——持久化</title>
    <link href="http://yoursite.com/2017/04/09/Redis-4/"/>
    <id>http://yoursite.com/2017/04/09/Redis-4/</id>
    <published>2017-04-09T15:12:54.000Z</published>
    <updated>2017-04-09T15:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a><strong>什么是持久化？</strong></h2><p>持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</p>
<a id="more"></a>
<p>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</p>
<p>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</p>
<p>我们这样理解：在一定周期内保持不变就是持久化，持久化是针对时间来说的。数据库中的数据就是持久化了的数据，只要你不去删除或修改。</p>
<h2 id="持久化选项"><a href="#持久化选项" class="headerlink" title="持久化选项"></a><strong>持久化选项</strong></h2><p>Redis提供了两种不同的持久化方法来将数据存储到硬盘中，保证数据在Redis重启后仍然存在：</p>
<ul>
<li>RDB持久化：在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot），也就是将存在于某一时刻的所有数据都写入硬盘里面，所以也叫作快照持久化。</li>
<li>AOF持久化：全称是 append-only file（只追加文件）， 它记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li>
</ul>
<p>这两种持久化的方式既可以单独使用，也可以同时使用，具体选择哪种方式需要根据用户的数据及应用进行选择。</p>
<p>下面的代码示例展示了Redis对于两种持久化选项提供的配置选项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 快照持久化选项</span></div><div class="line">save <span class="number">60</span> <span class="number">1000</span>  <span class="comment"># 60秒内有1000次写入操作的时候执行快照的创建</span></div><div class="line">stop-writes-on-bgsave-error no  <span class="comment"># 创建快照失败的时候是否仍然继续执行写命令</span></div><div class="line">rdbcompression yes  <span class="comment"># 是否对快照文件进行压缩</span></div><div class="line">dbfilename dump.rdb  <span class="comment"># 如何命名硬盘上的快照文件</span></div><div class="line">dir ./  <span class="comment"># 快照所保存的位置</span></div><div class="line"></div><div class="line"><span class="comment"># AOF持久化选项</span></div><div class="line">appendonly no  <span class="comment"># 是否使用AOF持久化</span></div><div class="line">appendfsync everysec  <span class="comment"># 多久才将写入的内容同步到硬盘</span></div><div class="line">no-appendfsync-on-rewrite no  <span class="comment"># 在对AOF进行压缩(compaction)的时候能否执行同步操作</span></div><div class="line">auto-aof-rewrite-percentage <span class="number">100</span>  <span class="comment"># 多久执行一次AOF压缩</span></div><div class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb  <span class="comment"># 多久执行一次AOF压缩</span></div><div class="line">dir ./  <span class="comment"># AOF所保存的位置</span></div></pre></td></tr></table></figure>
<h2 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）"></a><strong>快照持久化（RDB）</strong></h2><h3 id="创建快照的办法"><a href="#创建快照的办法" class="headerlink" title="创建快照的办法"></a><strong>创建快照的办法</strong></h3><ul>
<li><p>客户端通过向Redis发送BGSAVE命令来创建快照。</p>
<p>如果平台支持（除了Windows），那么Redis会调用fork来创建一个子进程，然后子进程负责将快照写到硬盘中，而父进程则继续处理命令请求。</p>
<p><strong>使用场景：</strong></p>
<p>如果用户使用了save设置，例如：<code>save 60 1000</code> ,那么从Redis最近一次创建快照之后开始计算，当“60秒之内有1000次写入操作”这个条件满足的时候，Redis就会自动触发BGSAVE命令。</p>
<p>如果用户使用了多个save设置，那么当任意一个save配置满足条件的时候，Redis都会触发一次BGSAVE命令。</p>
</li>
<li><p>客户端通过向Redis发SAVE命令来创建快照。</p>
<p>接收到SAVE命令的Redis服务器在快照创建完毕之前将不再响应任何其他命令的请求。SAVE命令并不常用，我们通常只在没有足够的内存去执行BGSAVE命令的时候才会使用SAVE命令，或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。</p>
<p><strong>使用场景：</strong></p>
<p>当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准的TERM信号时，会执行一次SAVE命令，阻塞所有的客户端，不再执行客户端发送的任何命令，并且在执行完SAVE命令之后关闭服务器。</p>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次快照文件，并且在每个月的每一天，也备份一个快照文件。 这样的话，即使遇到问题，也可以随时将数据集还原到不同的版本。</li>
<li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。</li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存快照文件时唯一要做的就是 <code>fork</code> 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul>
<li>如果在新的快照文件创建好之前，Redis、系统、硬件三者中任意一个发生崩溃，那么Redis将丢失最近一次创建快照之后写入的所有数据。如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。</li>
<li>每次保存 RDB 的时候，Redis 都要 <code>fork()</code> 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， <code>fork()</code>可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 <code>fork()</code> ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a><strong>AOF持久化</strong></h2><p>AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。这样，我们在恢复数据的时候，只需要从头到尾的执行一下AOF文件即可恢复数据。</p>
<p>我们可以通过<code>appendonly yes</code>命令来打开AOF持久化选项</p>
<h3 id="appendfsync同步频率"><a href="#appendfsync同步频率" class="headerlink" title="appendfsync同步频率"></a><strong>appendfsync同步频率</strong></h3><p>下表展示了appendfsync选项对AOF文件的同步频率的影响</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">同步频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">always</td>
<td style="text-align:center">每个Redis写命令都要同步写入硬盘。这样做会严重降低Redis的速度</td>
</tr>
<tr>
<td style="text-align:center">everysec</td>
<td style="text-align:center">每秒执行一次同步，显示地将多个写命令同步到硬盘</td>
</tr>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:center">让操作系统来决定应该何时进行同步</td>
</tr>
</tbody>
</table>
<ul>
<li><p>always的方式固然可以对没一条数据进行很好的保存，但是这种同步策略需要对硬盘进行大量的写操作，所以Redis处理命令的速度会受到硬盘性能的限制。</p>
<p>普通的硬盘每秒钟只能处理大约200个写命令，使用固态硬盘SSD每秒可以处理几万个写命令，但是每次只写一个命令，这种只能怪不断地写入很少量的数据的做法有可能引发严重的写入放大问题，这种情况下降严重影响固态硬盘的使用寿命。</p>
</li>
<li><p>everysec的方式，Redis以每秒一次的频率大队AOF文件进行同步。这样的话既可以兼顾数据安全也可以兼顾写入性能。</p>
<p>Redis以每秒同步一次AOF文件的性能和不使用任何持久化特性时的性能相差无几，使用每秒更新一次 的方式，可以保证，即使出现故障，丢失的数据也在一秒之内产生的数据。</p>
</li>
<li><p>no的方式，Redis将不对AOF文件执行任何显示的同步操作，而是由操作系统来决定应该何时对AOF文件进行同步。</p>
<p>这个命令一般不会对Redis的性能造成多大的影响，但是当系统出现故障的时候使用这种选项的Redis服务器丢失不定数量的数据。</p>
<p>另外，当用户的硬盘处理写入操作的速度不够快的话，那么缓冲区被等待写入硬盘的数据填满时，Redis的写入操作将被阻塞，并导致Redis处理命令请求的速度变慢，因为这个原因，一般不推荐使用这个选项。</p>
</li>
</ul>
<h3 id="重写-压缩AOF文件"><a href="#重写-压缩AOF文件" class="headerlink" title="重写/压缩AOF文件"></a><strong>重写/压缩AOF文件</strong></h3><p>随着数据量的增大，AOF的文件可能会很大，这样在每次进行数据恢复的时候就会进行很长的时间，为了解决日益增大的AOF文件，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，是AOF文件的体积变得尽可能的小。</p>
<p>BGREWRITEAOF的工作原理和BGSAVE的原理很像：Redis会创建一个子进程，然后由子进程负责对AOF文件的重写操作。</p>
<p>因为AOF文件重写的时候会创建子进程，所以快照持久化因为创建子进程而导致的性能和内存占用问题同样会出现在AOF文件重写的时候。</p>
<p>跟快照持久化通过save选项来自动执行BGSAVE一样，AOF通过设置<code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>选项来自动执行BGREWRITEAOF。</p>
<p>如下配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage <span class="number">100</span></div><div class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</div></pre></td></tr></table></figure>
<p>表示当前AOF的文件体积大于64MB，并且AOF文件的体积比上一次重写之后的体积变大了至少一倍（100%）的时候，Redis将执行重写BGREWRITEAOF命令。</p>
<p>如果AOF重写执行的过于频繁的话，可以将<code>auto-aof-rewrite-percentage</code>选项的值设置为100以上，这种最偶发就可以让Redis在AOF文件的体积变得更大之后才执行重写操作，不过，这也使得在进行数据恢复的时候执行的时间变得更加长一些。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 <code>fsync</code> 策略，比如无 <code>fsync</code> ，每秒钟一次 <code>fsync</code> ，或者每次执行写入命令时 <code>fsync</code> 。 AOF 的默认策略为每秒钟 <code>fsync</code> 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ <code>fsync</code> 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
<li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 <code>seek</code> ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， <code>redis-check-aof</code> 工具也可以轻易地修复这种问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 <a href="http://redisdoc.com/server/flushall.html#flushall" target="_blank" rel="external">FLUSHALL</a> 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 <a href="http://redisdoc.com/server/flushall.html#flushall" target="_blank" rel="external">FLUSHALL</a> 命令， 并重启 Redis ， 就可以将数据集恢复到 <a href="http://redisdoc.com/server/flushall.html#flushall" target="_blank" rel="external">FLUSHALL</a> 执行之前的状态。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 <code>fsync</code> 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 <code>fsync</code> 的性能依然非常高， 而关闭 <code>fsync</code> 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
<li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 <a href="http://redisdoc.com/list/brpoplpush.html#brpoplpush" target="_blank" rel="external">BRPOPLPUSH</a> 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li>
</ul>
<h3 id="如何选择RDB和AOF？"><a href="#如何选择RDB和AOF？" class="headerlink" title="如何选择RDB和AOF？"></a><strong>如何选择RDB和AOF？</strong></h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>
<h3 id="RDB-和-AOF-之间的相互作用"><a href="#RDB-和-AOF-之间的相互作用" class="headerlink" title="RDB 和 AOF 之间的相互作用"></a>RDB 和 AOF 之间的相互作用</h3><p>BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。</p>
<p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p>
<p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 <code>OK</code> 状态， 并告知用户，BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。</p>
<p>当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是持久化？&quot;&gt;&lt;a href=&quot;#什么是持久化？&quot; class=&quot;headerlink&quot; title=&quot;什么是持久化？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是持久化？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis, Python" scheme="http://yoursite.com/tags/Redis-Python/"/>
    
  </entry>
  
  <entry>
    <title>MxOnline项目学习总结</title>
    <link href="http://yoursite.com/2017/04/07/MxOnline-summary/"/>
    <id>http://yoursite.com/2017/04/07/MxOnline-summary/</id>
    <published>2017-04-07T13:18:54.000Z</published>
    <updated>2017-04-07T13:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>拖拖拉拉地学完了imooc的”强力django+杀手级xadmin打造上线标准的在线教育平台”课程，记录一下每一章学习的内容概要。<br><a id="more"></a></p>
<h1 id="MxOnline项目学习总结"><a href="#MxOnline项目学习总结" class="headerlink" title="MxOnline项目学习总结"></a>MxOnline项目学习总结</h1><h2 id="第一、二章"><a href="#第一、二章" class="headerlink" title="第一、二章"></a>第一、二章</h2><ul>
<li>课程介绍</li>
<li>开发环境搭建</li>
</ul>
<h2 id="第三章-django基础回顾"><a href="#第三章-django基础回顾" class="headerlink" title="第三章 django基础回顾"></a>第三章 django基础回顾</h2><ul>
<li>settings.py 设置</li>
<li>urls.py 配置</li>
<li>models.py 设计</li>
<li>views.py 编码</li>
<li>templates 模板编码</li>
</ul>
<h2 id="第四章-数据库设计"><a href="#第四章-数据库设计" class="headerlink" title="第四章 数据库设计"></a>第四章 数据库设计</h2><ul>
<li>users app model 设计</li>
<li>organization app model 设计</li>
<li>course app model 设计</li>
<li>operation app model 设计</li>
</ul>
<h2 id="第五章-后台管理系统开发"><a href="#第五章-后台管理系统开发" class="headerlink" title="第五章 后台管理系统开发"></a>第五章 后台管理系统开发</h2><ul>
<li>django admin 介绍</li>
<li>xadmin 安装和 model 注册</li>
<li>xadmin 全局配置</li>
</ul>
<h2 id="第六章-登录、注册、找回密码"><a href="#第六章-登录、注册、找回密码" class="headerlink" title="第六章 登录、注册、找回密码"></a>第六章 登录、注册、找回密码</h2><ul>
<li>登录（ session 和 cookie 机制）</li>
<li>注册（ form 表单提交、图片验证码，发送邮件 ）</li>
<li>找回密码（邮件发送）</li>
</ul>
<h2 id="第七章-课程机构功能实现"><a href="#第七章-课程机构功能实现" class="headerlink" title="第七章 课程机构功能实现"></a>第七章 课程机构功能实现</h2><ul>
<li>机构列表（分页，筛选、排序）</li>
<li>机构详情页（收藏，富文本展示）</li>
<li>咨询提交（ modelform 验证和保存）</li>
</ul>
<h2 id="第八章-课程功能实现"><a href="#第八章-课程功能实现" class="headerlink" title="第八章 课程功能实现"></a>第八章 课程功能实现</h2><ul>
<li>课程列表（分页、排序）</li>
<li>课程详情页（收藏，章节展示、资源展示、评论）</li>
</ul>
<h2 id="第九章-讲师功能实现"><a href="#第九章-讲师功能实现" class="headerlink" title="第九章 讲师功能实现"></a>第九章 讲师功能实现</h2><ul>
<li>讲师列表（分页、排序）</li>
<li>讲师详情（收藏）</li>
</ul>
<h2 id="第十章-个人中心功能实现"><a href="#第十章-个人中心功能实现" class="headerlink" title="第十章 个人中心功能实现"></a>第十章 个人中心功能实现</h2><ul>
<li>用户信息修改（修改密码、头像、邮箱、基本信息）</li>
<li>导航栏全局搜索功能</li>
<li>我的课程</li>
<li>我的收藏（删除收藏）</li>
<li>我的消息</li>
</ul>
<h2 id="第十一章-全局功能实现"><a href="#第十一章-全局功能实现" class="headerlink" title="第十一章 全局功能实现"></a>第十一章 全局功能实现</h2><ul>
<li>全局404和500页面配置</li>
<li>首页开发</li>
<li>点击数和收藏数修改和退出功能</li>
</ul>
<h2 id="第十二章-常见-web-攻击"><a href="#第十二章-常见-web-攻击" class="headerlink" title="第十二章 常见 web 攻击"></a>第十二章 常见 web 攻击</h2><ul>
<li>sql 注入攻击</li>
<li>xss 攻击</li>
<li>csrf 攻击</li>
</ul>
<h2 id="第十三章-xadmin-进阶开发"><a href="#第十三章-xadmin-进阶开发" class="headerlink" title="第十三章 xadmin 进阶开发"></a>第十三章 xadmin 进阶开发</h2><ul>
<li>userprofile 注册和设置</li>
<li>xadmin 常见功能设置</li>
<li>inlinemodel 注册、proxy 代理注册</li>
<li>django ueditor 富文本编辑器继承</li>
<li>excel 导入插件集成</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖拖拉拉地学完了imooc的”强力django+杀手级xadmin打造上线标准的在线教育平台”课程，记录一下每一章学习的内容概要。&lt;br&gt;
    
    </summary>
    
      <category term="Django, Python" scheme="http://yoursite.com/categories/Django-Python/"/>
    
    
      <category term="Django, Python" scheme="http://yoursite.com/tags/Django-Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记(三)：Redis命令补充</title>
    <link href="http://yoursite.com/2017/04/06/Redis-3/"/>
    <id>http://yoursite.com/2017/04/06/Redis-3/</id>
    <published>2017-04-06T12:18:54.000Z</published>
    <updated>2017-04-06T13:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的学习笔记中，还有许多Redis的命令没有涉及，这一篇主要用来简要地补充，当然，详细的命令还得参考Redis的<a href="http://www.redis.cn/commands.html" target="_blank" rel="external">官方命令文档</a>。<br><a id="more"></a></p>
<h2 id="键值相关命令"><a href="#键值相关命令" class="headerlink" title="键值相关命令"></a><strong>键值相关命令</strong></h2><p>下表展示了Redis提供的一些键值(KEY-VALUE)相关的常用命令及其redis-py API</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用例</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">KEYS</td>
<td style="text-align:center">KEYS pattern</td>
<td style="text-align:center">查找所有符合给定模式pattern(正则表达式)的key</td>
<td style="text-align:center">keys(pattern=’*’)</td>
</tr>
<tr>
<td style="text-align:center">EXISTS</td>
<td style="text-align:center">EXISTS key</td>
<td style="text-align:center">检查给定key是否存在</td>
<td style="text-align:center">exists(name)</td>
</tr>
<tr>
<td style="text-align:center">EXPIRE</td>
<td style="text-align:center">EXPIRE key seconds</td>
<td style="text-align:center">为给定key设置生存时间，当key过期时(生存时间为0)，它会被自动删除</td>
<td style="text-align:center">expire(name, time)</td>
</tr>
<tr>
<td style="text-align:center">MOVE</td>
<td style="text-align:center">MOVE key db</td>
<td style="text-align:center">将当前数据库的key移动到给定的数据库db当中</td>
<td style="text-align:center">move(name, db)</td>
</tr>
<tr>
<td style="text-align:center">PERSIST</td>
<td style="text-align:center">PERSIST key</td>
<td style="text-align:center">移除给定key的生存时间，将这个key从『易失的』(带生存时间key)转换成『持久的』(一个不带生存时间、永不过期的key)</td>
<td style="text-align:center">persist(name)</td>
</tr>
<tr>
<td style="text-align:center">RANDOMKEY</td>
<td style="text-align:center">RANDOMKEY</td>
<td style="text-align:center">从当前数据库返回一个随机的key</td>
<td style="text-align:center">randomkey()</td>
</tr>
<tr>
<td style="text-align:center">RENAME</td>
<td style="text-align:center">RENAME key newkey</td>
<td style="text-align:center">将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖</td>
<td style="text-align:center">rename(src, dst)</td>
</tr>
<tr>
<td style="text-align:center">TYPE</td>
<td style="text-align:center">TYPE key</td>
<td style="text-align:center">返回key所存储的value的数据结构类型，它可以返回string, list, set, zset和hash等不同的类型</td>
<td style="text-align:center">type(name)</td>
</tr>
<tr>
<td style="text-align:center">TTL</td>
<td style="text-align:center">TTL key</td>
<td style="text-align:center">返回key剩余的过期时间(单位：秒)</td>
<td style="text-align:center">ttl(name)</td>
</tr>
</tbody>
</table>
<p>下面这个交互示例展示了Redis中关于键的过期时间相关的命令的使用方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'key'</span>, <span class="string">'value'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'key'</span>)</div><div class="line"><span class="string">b'value'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.expire(<span class="string">'key'</span>, <span class="number">2</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.sleep(<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'key'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'key'</span>, <span class="string">'value2'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.expire(<span class="string">'key'</span>, <span class="number">100</span>); r.ttl(<span class="string">'key'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure>
<h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a><strong>发布与订阅</strong></h2><p>发布订阅(pub/sub)是一种消息通信模式，主要的目的是解耦消息发布者和消息订阅者之间的耦合，这点和设计模式中的观察者模式比较相似。pub/sub不仅仅解决发布者和订阅者之间代码级别耦合也解决两者在物理部署上的耦合。Redis作为一个pub/sub的server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向 redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道(channel)。当发布者通过publish命令向 redis server发送二进制字符串消息(binary string message)时，订阅该消息类型的全部client都会收到此消息。这里消息的传递是多对多的，一个client可以订阅多个channel，也可以向多个channel发送消息。</p>
<p>下表展示了Redis提供的发布与订阅命令及其redis-py API</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用例</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SUBSCRIBE</td>
<td style="text-align:center">SUBSCRIBE channel [channel …]</td>
<td style="text-align:center">订阅给定的频道</td>
<td style="text-align:center">subscribe(<em>args, *</em>kwargs)</td>
</tr>
<tr>
<td style="text-align:center">UNSUBSCRIBE</td>
<td style="text-align:center">UNSUBSCRIBE [channel [channel …]]</td>
<td style="text-align:center">退订给定的频道，如果没有给定任何频道，则退订所有频道</td>
<td style="text-align:center">unsubscribe(*args)</td>
</tr>
<tr>
<td style="text-align:center">PUBLISH</td>
<td style="text-align:center">PUBLISH channel message</td>
<td style="text-align:center">将信息message发送到指定的频道channel</td>
<td style="text-align:center">publish(channel, message)</td>
</tr>
<tr>
<td style="text-align:center">PSUBSCRIBE</td>
<td style="text-align:center">PSUBSCRIBE pattern [pattern …]</td>
<td style="text-align:center">订阅与给定模式相关的频道</td>
<td style="text-align:center">psubscribe(<em>args, *</em>kwargs)</td>
</tr>
<tr>
<td style="text-align:center">PUNSUBSCRIBE</td>
<td style="text-align:center">PUNSUBSCRIBE [pattern [pattern …]]</td>
<td style="text-align:center">退订给定的模式，如果没有给定，则退订所有模式</td>
<td style="text-align:center">PUNSUBSCRIBE [pattern [pattern …]]</td>
</tr>
<tr>
<td style="text-align:center">PUBSUB</td>
<td style="text-align:center">PUBSUB subcommand [argument [argument …]]</td>
<td style="text-align:center">PUBSUB命令是一个introspection命令，允许检查Pub/Sub子系统的状态，它由单独记录的子命令组成</td>
<td style="text-align:center">pubsub(**kwargs)</td>
</tr>
</tbody>
</table>
<p>考虑到PUBLISH命令和SUBSCRIBE命令在Python客户端的实现方式，一个比较简单的延时发布与订阅的方法，就是像如下代码那样用辅助线程(helper thread)来执行PUBLISH命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line">pool = redis.ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line">r = redis.StrictRedis(connection_pool=pool)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">publisher</span><span class="params">(n)</span>:</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        r.publish(<span class="string">'channel'</span>, i)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_pubsub</span><span class="params">()</span>:</span></div><div class="line">    threading.Thread(target=publisher, args=(<span class="number">3</span>,)).start()</div><div class="line">    pubsub = r.pubsub()</div><div class="line">    pubsub.subscribe([<span class="string">'channel'</span>])</div><div class="line">    count=<span class="number">0</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> pubsub.listen():</div><div class="line">        print(item)</div><div class="line">        count += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> count == <span class="number">4</span>:</div><div class="line">            pubsub.unsubscribe()</div><div class="line">        <span class="keyword">if</span> count == <span class="number">5</span>:</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>publisher函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。在发布消息之后进行短暂的休眠，让消息可以一条接一条地出现。</p>
<p>run_pubsub函数启动发送者线程，让它发送三条消息。随后创建发布与订阅对象，并让它订阅给定的频道。通过遍历函数pubsub.listen()的执行结果来监听订阅消息。在接收到一条订阅反馈消息和三条发布者发送的消息之后，执行退订操作，停止监听新消息。客户端在接收到退订反馈消息之后，就不再接收消息。</p>
<p>实际运行函数并观察它们的行为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>run_pubsub()</div><div class="line">&#123;<span class="string">'type'</span>: <span class="string">'subscribe'</span>, <span class="string">'channel'</span>: <span class="string">b'channel'</span>, <span class="string">'data'</span>: <span class="number">1</span>, <span class="string">'pattern'</span>: <span class="keyword">None</span>&#125;</div><div class="line">&#123;<span class="string">'type'</span>: <span class="string">'message'</span>, <span class="string">'channel'</span>: <span class="string">b'channel'</span>, <span class="string">'data'</span>: <span class="string">b'0'</span>, <span class="string">'pattern'</span>: <span class="keyword">None</span>&#125;</div><div class="line">&#123;<span class="string">'type'</span>: <span class="string">'message'</span>, <span class="string">'channel'</span>: <span class="string">b'channel'</span>, <span class="string">'data'</span>: <span class="string">b'1'</span>, <span class="string">'pattern'</span>: <span class="keyword">None</span>&#125;</div><div class="line">&#123;<span class="string">'type'</span>: <span class="string">'message'</span>, <span class="string">'channel'</span>: <span class="string">b'channel'</span>, <span class="string">'data'</span>: <span class="string">b'2'</span>, <span class="string">'pattern'</span>: <span class="keyword">None</span>&#125;</div><div class="line">&#123;<span class="string">'type'</span>: <span class="string">'unsubscribe'</span>, <span class="string">'channel'</span>: <span class="string">b'channel'</span>, <span class="string">'data'</span>: <span class="number">0</span>, <span class="string">'pattern'</span>: <span class="keyword">None</span>&#125;</div></pre></td></tr></table></figure></p>
<p>以上这些结构就是我们在遍历pubsub.listen()函数时得到的元素。</p>
<p>在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。在退订频道时，客户端会接收到一条反馈消息，告知被退订的是哪一个频道，以及客户端目前仍在订阅的频道数量。</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a><strong>其他命令</strong></h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h3><p>Redis中负责执行排序操作的SORT命令可以根据字符串、列表、集合、有序集合、散列这5中键里面存储的数据，对列表、集合以及有序集合进行排序，可以将SORT命令看作是SQL语言中的order by子句。</p>
<p>下表展示了SORT命令的定义及其redis-py API</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用例</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SORT</td>
<td style="text-align:center">SORT key [BY pattern][LIMIT offset count] [GET pattern][ASC\</td>
<td style="text-align:center">DESC] [ALPHA] destination</td>
<td style="text-align:center">返回或存储key的list、set或sorted set中的元素。默认是按照数值类型排序的，并且按照两个元素的双精度浮点数类型值进行比较</td>
<td>sort(name, start=None, num=None, by=None, get=None, desc=False, alpha=False, store=None, groups=False)</td>
</tr>
</tbody>
</table>
<p>下面展示了SORT命令的一些简单的用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'sort-input'</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">110</span>, <span class="number">7</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sort(<span class="string">'sort-input'</span>)</div><div class="line">[<span class="string">b'7'</span>, <span class="string">b'15'</span>, <span class="string">b'23'</span>, <span class="string">b'110'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sort(<span class="string">'sort-input'</span>, alpha=<span class="keyword">True</span>)</div><div class="line">[<span class="string">b'110'</span>, <span class="string">b'15'</span>, <span class="string">b'23'</span>, <span class="string">b'7'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hset(<span class="string">'d-7'</span>, <span class="string">'field'</span>, <span class="number">5</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hset(<span class="string">'d-15'</span>, <span class="string">'field'</span>, <span class="number">1</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hset(<span class="string">'d-23'</span>, <span class="string">'field'</span>, <span class="number">9</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hset(<span class="string">'d-110'</span>, <span class="string">'field'</span>, <span class="number">3</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sort(<span class="string">'sort-input'</span>, by=<span class="string">'d-*-&gt;field'</span>)</div><div class="line">[<span class="string">b'15'</span>, <span class="string">b'110'</span>, <span class="string">b'7'</span>, <span class="string">b'23'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sort(<span class="string">'sort-input'</span>, by=<span class="string">'d-*-&gt;field'</span>, get=<span class="string">'d-*-&gt;field'</span>)</div><div class="line">[<span class="string">b'1'</span>, <span class="string">b'3'</span>, <span class="string">b'5'</span>, <span class="string">b'9'</span>]</div></pre></td></tr></table></figure></p>
<p>SORT命令不仅可以对列表进行排序，还可以对集合进行排序，然后返回一个列表形式的排序结果。上述代码除了展示如何使用alpha关键字(根据元素字母表顺序，默认根据大小)参数对元素进行字符串排序之外，还展示了如何基于外部数据对元素进行排序，以及如何获取并返回外部数据。</p>
<p>尽管SORT是Redis中唯一一个可以同时处理3种不同类型的数据的命令，但是事务同样可以让我们在一连串不间断执行的命令里面操作不同类型的数据。</p>
<h3 id="基本的Redis事务"><a href="#基本的Redis事务" class="headerlink" title="基本的Redis事务"></a><strong>基本的Redis事务</strong></h3><p>Redis中的事务(transaction)是一组命令的集合。MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。</p>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部执行，要么全不执行。</li>
</ul>
<p>事务的应用非常普遍，比如银行汇款过程中A向B汇款，系统先从A的账户中将钱划走，然后向B的账户中增加相应的金额。这两个步骤必须属于同一个事务，要么全部执行，要么全不执行。</p>
<p>Redis的基本事务(basic transaction)需要用到MULTI和EXEC命令。在Redis中，被MULTI和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕后，才会处理其他客户端的命令。</p>
<p>Redis中执行事务的步骤：首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，最后再执行EXEC命令。MULTI命令用于开启一个事务，它总是返回OK 。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。另一方面，通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务。EXEC命令的回复是一个数组，数组中的每个元素都是执行事务中的命令所产生的回复。其中，回复元素的先后顺序和命令发送的先后顺序一致。当客户端处于事务状态时，所有传入的命令都会返回一个内容为QUEUED的状态回复status reply，这些被入队的命令将在EXEC命令被调用时执行。</p>
<p>从语义上来说，Redis事务在Python客户端中是由管道(pipeline)实现的：对连接对象调用pipeline()方法将创建一个事务，在一切正常的情况下，客户端会自动地调用MULTI命令包裹用户输入的多个命令。此外，为了减少Redis与客户端之间的通信往返次数，提升执行多个命令的性能，Python的Redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令都发送给Redis。</p>
<p>要展示事务执行的结果，最简单的方法就是将事务放到线程里面执行，下面这个交互示例展示了在没有使用事务的情况下，执行并行(parallel)自增操作的结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> threading</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">notrans</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(r.incr(<span class="string">'notrans:'</span>))</div><div class="line"><span class="meta">... </span>    time.sleep(<span class="number">.1</span>)</div><div class="line"><span class="meta">... </span>    r.incr(<span class="string">'notrans:'</span>, <span class="number">-1</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">1</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line"><span class="meta">... </span>            threading.Thread(target=notrans).start()</div><div class="line"><span class="meta">... </span>    time.sleep(<span class="number">.5</span>)</div><div class="line">...</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>上述代码启动了3个线程来执行没有被事务包裹的自增、休眠和自减操作，正因为没有使用事务，所以三个线程都可以在执行自减操作前，对notrans:计数器执行自增操作。</p>
<p>下面这个交互示例就展示了如何使用事务处理命令的并行执行问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">trans</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    pipeline = r.pipeline()</div><div class="line"><span class="meta">... </span>    pipeline.incr(<span class="string">'trans:'</span>)</div><div class="line"><span class="meta">... </span>    time.sleep(<span class="number">.1</span>)</div><div class="line"><span class="meta">... </span>    pipeline.incr(<span class="string">'trans:'</span>, <span class="number">-1</span>)</div><div class="line"><span class="meta">... </span>    print(pipeline.execute()[<span class="number">0</span>])</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">1</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line"><span class="meta">... </span>            threading.Thread(target=trans).start()</div><div class="line"><span class="meta">... </span>    time.sleep(<span class="number">.5</span>)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>首先在trans函数中创建一个事务型(transactional)管道对象，然后先把针对’tans:’计数器的自增操作放入队列，等待100ms后再将针对’tans:’计数器的自减操作放入队列，最后执行被事务包裹的命令，并打印自增操作的执行结果。最终在执行结果中可以看到，尽管自增和自减操作之间有一段延迟时间，但通过使用事务，各个线程都可以在不被其他线程打断的情况下，执行各自队列里面的命令。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的学习笔记中，还有许多Redis的命令没有涉及，这一篇主要用来简要地补充，当然，详细的命令还得参考Redis的&lt;a href=&quot;http://www.redis.cn/commands.html&quot;&gt;官方命令文档&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis, Python" scheme="http://yoursite.com/tags/Redis-Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记(二)：Redis命令及其Python API</title>
    <link href="http://yoursite.com/2017/03/27/Redis-2/"/>
    <id>http://yoursite.com/2017/03/27/Redis-2/</id>
    <published>2017-03-27T08:18:54.000Z</published>
    <updated>2017-03-30T12:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis-py简介"><a href="#redis-py简介" class="headerlink" title="redis-py简介"></a><strong>redis-py简介</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>在之前的学习笔记(一)中已经安装过<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">redis-py</a>，我的Python版本是3.5.2<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip3 install redis</div></pre></td></tr></table></figure></p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><strong>快速开始</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'key'</span>, <span class="string">'value'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'key'</span>)</div><div class="line"><span class="string">b'value'</span></div></pre></td></tr></table></figure>
<h3 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a><strong>API参考</strong></h3><p>Redis的<a href="http://www.redis.cn/commands.html" target="_blank" rel="external">官方命令文档</a>很好地解释了每个命令的详细信息。 redis-py公开了实现这些命令的两个客户端类。 </p>
<p>第一，StrictRedis类试图遵守官方命令语法， 但是有些一些例外：</p>
<ul>
<li>SELECT: 没有实现，考虑到线程安全的原因。</li>
<li>DEL: 由于del是python语法关键字，所用delete来代替。</li>
<li>CONFIG GET|SET: 分开用 config_get or config_set来代替</li>
<li>MULTI/EXEC: 事务作为Pipeline类的其中一部分的实现。Pipeline默认保证了MULTI,EXEC声明。但是你可以指定transaction=False来禁用这一行为。</li>
<li>SUBSCRIBE/LISTEN:PubSub作为一个独立的类来实现发布订阅机制。</li>
<li>SCAN/SSCAN/HSCAN/ZSCAN:每个命令都对应一个等价的迭代器方法scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior。</li>
</ul>
<p>第二，Redis类是StrictRedis的子类，提供redis-py版本向后的兼容性。</p>
<p>关于StrictRedis与Redis的区别：(官方推荐使用StrictRedis.)</p>
<p>以下几个方法在StrictRedis和Redis类中的参数顺序不同。</p>
<ul>
<li>LREM: 在Redis类中是这样的：<br>lrem(self, name, value, num=0)<br>在StrictRedis类中是这样的：<br>lrem(self, name, count, value)</li>
<li>ZADD: 在Redis类中是这样的：<br>zadd(‘my-key’, ‘name1’, 1.1, ‘name2’, 2.2, name3=3.3, name4=4.4)<br>在StrictRedis中是这样的：<br>zadd(‘my-key’, 1.1, ‘name1’, 2.2, ‘name2’, name3=3.3, name4=4.4)</li>
<li>SETEX: 在Redis类中是这样的：<br>setex(self, name, value, time)<br>而在StrictRedis中是这样的：<br>setex(self, name, time, value)</li>
</ul>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h3><p> redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认情况下，每个Redis实例都会依次创建并维护一个自己的连接池。我们可以直接建立一个连接池，然后传递给Redis或StrictRedis连接命令作为参数，这样就可以实现多个Redis实例共享一个连接池，以实现客户端分片，或者对连接的管理方式进行更高精度的控制。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(connection_pool=pool)</div></pre></td></tr></table></figure></p>
<p> 我们也可以创建自己的Connection子类，用于控制异步框架中的套接字行为，要使用自己的连接实例化客户端类，需要创建一个连接池，将类传递给connection_class参数。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(connection_class=YourConnectionClass,your_arg=<span class="string">'...'</span>, ...)</div></pre></td></tr></table></figure></p>
<p> 释放连接回到连接池：可以使用Redis类的reset()方法，或者使用with上下文管理语法。</p>
<p> 解析器：解析器控制如何解析Redis-server的响应内容，redis-py提供两种方式的解析器类支持PythonParser和HiredisParser(需要单独安装)。它优先选用HiredisParser,如果不存在，则选用PythonParser. Hiredis是redis核心团队开发的一个高性能c库，能够提高10x的解析速度。</p>
<p>响应回调：The client class使用一系列的callbacks来完成响应到对应python类型的映射。这些响应回调，定义在 Redis client class中的RESPONSE_CALLBACKS字典中。你可以使用set_response_callback 方法来添加自定义回调类。这个方法接受两个参数：一个命令名字，一个回调类。回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数。</p>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h3><p>Redis客户端实例可以安全地在线程之间共享。 在内部，连接实例只在命令执行期间从连接池检索，并在执行后直接返回到池中。 命令执行过程从不修改客户端实例上的状态。</p>
<p>但是，有一个警告：Redis SELECT命令。 SELECT命令允许您切换连接正在使用的数据库。 该数据库保持选中，直到选择另一个或连接关闭为止。 这会创建一个问题，因为可以将连接返回到连接到不同数据库的池。</p>
<p>因此，redis-py不会在客户端实例上实现SELECT命令。 如果在同一应用程序中使用多个Redis数据库，则应为每个数据库创建一个单独的客户机实例（也可能是单独的连接池）。</p>
<p>在线程之间传递PubSub或Pipeline对象是不安全的。</p>
<h2 id="Redis命令及其对应redis-py-API"><a href="#Redis命令及其对应redis-py-API" class="headerlink" title="Redis命令及其对应redis-py API"></a><strong>Redis命令及其对应redis-py API</strong></h2><p>由于Redis<a href="http://www.redis.cn/commands.html" target="_blank" rel="external">官方命令文档</a>很好地解释了每个命令的详细信息，所以我这里只对最常用的Redis命令进行整理，并给出其redis-py API。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h3><p>下表展示了对Redis字符串执行自增和自减操作的命令及其redis-py API。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>INCR</td>
<td>INCR key-name</td>
<td>将键存储的值加1</td>
<td>incr(name, amount=1)</td>
</tr>
<tr>
<td>DECR</td>
<td>DECR key-name</td>
<td>将键存储的值减1</td>
<td>decr(name, amount=1)</td>
</tr>
<tr>
<td>INCRBY</td>
<td>INCRBY key-name amount</td>
<td>将键存储的值加整数amount</td>
<td>incr(name, amount=1)</td>
</tr>
<tr>
<td>DECRBY</td>
<td>DECRBY key-name amount</td>
<td>将键存储的值减整数amount</td>
<td>decr(name, amount=1)</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>INCRBYFLOAT key-name amount</td>
<td>将键存储的值加浮点数amount</td>
<td>incrbyfloat(name, amount=1.0)</td>
</tr>
</tbody>
</table>
<p>在redis-py内部，使用了INCRBY和DECRBY命令来实现incr()和decr()方法，并且第二个参数amount是可选的，默认为1。</p>
<p>下面这个交互示例展示了Redis的INCR和DECR操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'key'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.incr(<span class="string">'key'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.incr(<span class="string">'key'</span>, <span class="number">15</span>)</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'key'</span>)</div><div class="line"><span class="string">b'16'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.decr(<span class="string">'key'</span>, <span class="number">5</span>)</div><div class="line"><span class="number">11</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'key'</span>, <span class="number">13</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.incr(<span class="string">'key'</span>)</div><div class="line"><span class="number">14</span></div></pre></td></tr></table></figure></p>
<p>当用户将一个值存储到Redis字符串中时，如果这个值可以被解释(interpet)为十进制整数或者浮点数，那么Redis会允许用户对这个字符串执行各种INCR<em>和DECR</em>操作。如果用户对一个不存在的键或者一个保存了空串的键执行自增或自减操作，Redis会自动将这个键的值当作是0来处理。若非上述情况，则Redis将会返回一个错误。</p>
<p>除了自增和自减操作，Redis还可以对字节串进行读取和写入的操作。</p>
<p>下表展示了Redis用来处理字符串子串和二进制位的命令及其redis-py API。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>APPEND</td>
<td>APPEND key-name value</td>
<td>将值value追加到给定键key-name当前存储的值的末尾</td>
<td>append(key, value)</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>GETRANGE key-name start end</td>
<td>获取一个偏移量从start到end的子串，包含start和end</td>
<td>getrange(key, start, end)</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>SETRANGE key-name offset value</td>
<td>将从start开始的子串设置为给定值</td>
<td>setrange(name, offset, value)</td>
</tr>
<tr>
<td>GETBIT</td>
<td>GETBIT key-name offset</td>
<td>将字节串看作是二进制位串，并返回位串中偏移量为offset的二进制位的值</td>
<td>getbit(name, offset)</td>
</tr>
<tr>
<td>SETBIT</td>
<td>SETBIT key-name offset value</td>
<td>将字节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设为value</td>
<td>setbit(name, offset, value)</td>
</tr>
<tr>
<td>BITCOUNT</td>
<td>BITCOUNT key-name [start end]</td>
<td>统计字符串被设置为1的bit数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行</td>
<td>bitcount(key, start=None, end=None)</td>
</tr>
<tr>
<td>BITOP</td>
<td>BITOP operation dest-key key-name [key-name …]</td>
<td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td>
<td>bitop(operation, dest, *keys)</td>
</tr>
</tbody>
</table>
<p>在执行SETRANGE或者SETBIT命令时，如果offset比当前key对应string还要长，那这个string后面就补空字节(null)以达到offset。使用GETRANGE时超出字符串末尾的数据会被认为是空字符串，而使用GETBIT时超出字符串末尾的二进制位会被视为是0。</p>
<p>下面这个交互示例展示了Redis的子串操作和二进制位操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.append(<span class="string">'new-string-key'</span>, <span class="string">'hello '</span>)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.append(<span class="string">'new-string-key'</span>, <span class="string">'world!'</span>)</div><div class="line"><span class="number">12</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.substr(<span class="string">'new-string-key'</span>, <span class="number">3</span>, <span class="number">7</span>)</div><div class="line"><span class="string">b'lo wo'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.getrange(<span class="string">'new-string-key'</span>, <span class="number">3</span>, <span class="number">7</span>)</div><div class="line"><span class="string">b'lo wo'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.setrange(<span class="string">'new-string-key'</span>, <span class="number">0</span>, <span class="string">'H'</span>)</div><div class="line"><span class="number">12</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'new-string-key'</span>)</div><div class="line"><span class="string">b'Hello world!'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.setrange(<span class="string">'new-string-key'</span>, <span class="number">11</span>, <span class="string">', how are you?'</span>)</div><div class="line"><span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'new-string-key'</span>)</div><div class="line"><span class="string">b'Hello world, how are you?'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.setbit(<span class="string">'another-key'</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.setbit(<span class="string">'another-key'</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.getbit(<span class="string">'another-key'</span>, <span class="number">1</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'another-key'</span>)</div><div class="line"><span class="string">b'!'</span></div></pre></td></tr></table></figure></p>
<p>Redis现在的GETRANGE命令是由以前的SUBSTR命令改名而来，所以现在redis-py中两者仍然都可以使用，但是最好还是使用getrange()方法来获取子串。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h3><p>下表展示了一些之前介绍过的常用列表命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td>RPUSH key value [value …]</td>
<td>向存于key的列表的尾部插入所有指定的值</td>
<td>rpush(name, *values)</td>
</tr>
<tr>
<td>LPUSH</td>
<td>LPUSH key value [value …]</td>
<td>将所有指定的值插入到存于key的列表的头部</td>
<td>lpush(name, *values)</td>
</tr>
<tr>
<td>RPOP</td>
<td>RPOP key</td>
<td>移除并返回key对应的list的最后一个元素</td>
<td>rpop(name)</td>
</tr>
<tr>
<td>LPOP</td>
<td>LPOP key</td>
<td>移除并返回key对应的list的第一个元素</td>
<td>lpop(name)</td>
</tr>
<tr>
<td>LINDEX</td>
<td>LINDEX key index</td>
<td>返回列表索引位置的元素</td>
<td>lindex(name, index)</td>
</tr>
<tr>
<td>LRANGE</td>
<td>LRANGE key start stop</td>
<td>返回存储在key的列表里指定范围内的元素</td>
<td>lrange(name, start, end)</td>
</tr>
<tr>
<td>LTRIM</td>
<td>LTRIM key start stop</td>
<td>修剪(trim)一个已存在的list，这样list就会只包含指定范围的指定元素</td>
<td>ltrim(name, start, end)</td>
</tr>
</tbody>
</table>
<p>下面这个交互示例展示了Redis列表的推入和弹出操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'list-key'</span>, <span class="string">'last'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lpush(<span class="string">'list-key'</span>, <span class="string">'first'</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'list-key'</span>, <span class="string">'new last'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lrange(<span class="string">'list-key'</span>, <span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">[<span class="string">b'first'</span>, <span class="string">b'last'</span>, <span class="string">b'new last'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lpop(<span class="string">'list-key'</span>)</div><div class="line"><span class="string">b'first'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lpop(<span class="string">'list-key'</span>)</div><div class="line"><span class="string">b'last'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lrange(<span class="string">'list-key'</span>, <span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">[<span class="string">b'new last'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'list-key'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lrange(<span class="string">'list-key'</span>, <span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">[<span class="string">b'new last'</span>, <span class="string">b'a'</span>, <span class="string">b'b'</span>, <span class="string">b'c'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.ltrim(<span class="string">'list-key'</span>, <span class="number">2</span>, <span class="number">-1</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lrange(<span class="string">'list-key'</span>, <span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">[<span class="string">b'b'</span>, <span class="string">b'c'</span>]</div></pre></td></tr></table></figure></p>
<p>还有几个列表命令能将元素从一个列表移动到另一个列表，或者阻塞(block)执行命令的客户端直到有其他客户端给列表添加元素为止。</p>
<p>下表列出了这些阻塞弹出命令以及列表之间移动元素的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP</td>
<td>BLPOP key [key …] timeout</td>
<td>弹出第一个非空列表的头元素，或在timeout秒内阻塞并等待可弹出的元素出现</td>
<td>blpop(keys, timeout=0)</td>
</tr>
<tr>
<td>BRPOP</td>
<td>BRPOP key [key …] timeout</td>
<td>弹出第一个非空列表的末尾元素，或在timeout秒内阻塞并等待可弹出的元素出现</td>
<td>brpop(keys, timeout=0)</td>
</tr>
<tr>
<td>RPOPLPUSH</td>
<td>RPOPLPUSH source destination</td>
<td>原子性地返回并移除存储在source的列表的最后一个元素(列表尾部元素)， 并把该元素放入存储在destination的列表的第一个元素位置(列表头部)</td>
<td>rpoplpush(src, dst)</td>
</tr>
<tr>
<td>BRPOPLPUSH</td>
<td>BRPOPLPUSH source destination timeout</td>
<td>BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。</td>
<td>brpoplpush(src, dst, timeout=0)</td>
</tr>
</tbody>
</table>
<p>注：原子性是指命令正在都区或者修改数据的时候，其他客户端不能读取或修改相同的数据。</p>
<p>下面这个交互示例展示了Redis列表的阻塞弹出命令以及元素移动命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'list'</span>, <span class="string">'item1'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'list'</span>, <span class="string">'item2'</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.rpush(<span class="string">'list2'</span>, <span class="string">'item3'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.brpoplpush(<span class="string">'list2'</span>, <span class="string">'list'</span>, <span class="number">1</span>)</div><div class="line"><span class="string">b'item3'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.brpoplpush(<span class="string">'list2'</span>, <span class="string">'list'</span>, <span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.lrange(<span class="string">'list'</span>, <span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">[<span class="string">b'item3'</span>, <span class="string">b'item1'</span>, <span class="string">b'item2'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.brpoplpush(<span class="string">'list'</span>, <span class="string">'list2'</span>, <span class="number">1</span>)</div><div class="line"><span class="string">b'item2'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.blpop([<span class="string">'list'</span>, <span class="string">'list2'</span>], <span class="number">1</span>)</div><div class="line">(<span class="string">b'list'</span>, <span class="string">b'item3'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.blpop([<span class="string">'list'</span>, <span class="string">'list2'</span>], <span class="number">1</span>)</div><div class="line">(<span class="string">b'list'</span>, <span class="string">b'item1'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.blpop([<span class="string">'list'</span>, <span class="string">'list2'</span>], <span class="number">1</span>)</div><div class="line">(<span class="string">b'list2'</span>, <span class="string">b'item2'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.blpop([<span class="string">'list'</span>, <span class="string">'list2'</span>], <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>对于阻塞弹出命令和弹出并推入命令，最常见的用例就是消息传递(messaging)和任务队列(task queue)。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h3><p>下表展示了一部分最常用的集合命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>SADD key member [member …]</td>
<td>添加一个或多个指定的member元素到key集合中</td>
<td>sadd(name, *values)</td>
</tr>
<tr>
<td>SREM</td>
<td>SREM key member [member …]</td>
<td>在key集合中移除指定的元素</td>
<td>srem(name, *values)</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>SISMEMBER key member</td>
<td>返回成员member是否是存储的集合key的成员</td>
<td>sismember(name, value)</td>
</tr>
<tr>
<td>SCARD</td>
<td>SCARD key</td>
<td>返回集合包含元素的数量</td>
<td>scard(name)</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>SMEMBERS key</td>
<td>返回key集合所有的元素</td>
<td>smembers(name)</td>
</tr>
<tr>
<td>SRANDMEMBER</td>
<td>SRANDMEMBER key [count]</td>
<td>仅提供key参数,那么随机返回key集合中的一个元素，返回含有 count 个不同的元素的数组，对count分情况处理</td>
<td>srandmember(name, number=None)</td>
</tr>
<tr>
<td>SPOP</td>
<td>SPOP key [count]</td>
<td>从key对应集合中返回并删除一个或多个元素</td>
<td>spop(name)</td>
</tr>
<tr>
<td>SMOVE</td>
<td>SMOVE source destination member</td>
<td>将member从source集合移动到destination集合中</td>
<td>smove(src, dst, value)</td>
</tr>
</tbody>
</table>
<p>下面这个交互示例展示了这些常用的集合命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sadd(<span class="string">'set-key'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.srem(<span class="string">'set-key'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.srem(<span class="string">'set-key'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.scard(<span class="string">'set-key'</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.smembers(<span class="string">'set-key'</span>)</div><div class="line">&#123;<span class="string">b'b'</span>, <span class="string">b'a'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.smove(<span class="string">'set-key'</span>, <span class="string">'set-key2'</span>, <span class="string">'a'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.smove(<span class="string">'set-key'</span>, <span class="string">'set-key2'</span>, <span class="string">'c'</span>)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.smembers(<span class="string">'set-key2'</span>)</div><div class="line">&#123;<span class="string">b'a'</span>&#125;</div></pre></td></tr></table></figure></p>
<p>但是集合真正厉害的地方在于组合和关联多个集合，下表展示了相关的Redis命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>SDIFF</td>
<td>SDIFF key [key …]</td>
<td>返回一个集合与给定集合的差集的元素</td>
<td>sdiff(keys, *args)</td>
</tr>
<tr>
<td>SDIFFSTORE</td>
<td>SDIFFSTORE destination key [key …]</td>
<td>类似于 SDIFF，不同之处在于该命令不返回结果集，而是将结果存放在destination集合中，如果destination已经存在, 则将其覆盖重写</td>
<td>sdiffstore(dest, keys, *args)</td>
</tr>
<tr>
<td>SINTER</td>
<td>SINTER key [key …]</td>
<td>返回指定所有的集合的成员的交集</td>
<td>sinter(keys, *args)</td>
</tr>
<tr>
<td>SINTERSTORE</td>
<td>SINTERSTORE destination key [key …]</td>
<td>与SINTER命令类似，但是它并不是直接返回结果集，而是将结果保存在 destination集合中，如果destination集合存在, 则会被重写</td>
<td>sinterstore(dest, keys, *args)</td>
</tr>
<tr>
<td>SUNION</td>
<td>SUNION key [key …]</td>
<td>返回给定的多个集合的并集中的所有成员</td>
<td>sunion(keys, *args)</td>
</tr>
<tr>
<td>SUNIONSTORE</td>
<td>SUNIONSTORE destination key [key …]</td>
<td>类似于SUNION命令，不同的是它并不返回结果集，而是将结果存储在destination集合中，如果destination已经存在，则将其覆盖.</td>
<td>sunionstore(dest, keys, *args)</td>
</tr>
</tbody>
</table>
<p>这些命令分别是并集运算、交集运算和差集运算这三个基本集合操作的“返回结果”版本和“存储结果”版本，下面这个交互示例展示了这些命令的基本使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sadd(<span class="string">'skey1'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sadd(<span class="string">'skey2'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sdiff(<span class="string">'skey1'</span>, <span class="string">'skey2'</span>)</div><div class="line">&#123;<span class="string">b'b'</span>, <span class="string">b'a'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sinter(<span class="string">'skey1'</span>, <span class="string">'skey2'</span>)</div><div class="line">&#123;<span class="string">b'c'</span>, <span class="string">b'd'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sunion(<span class="string">'skey1'</span>, <span class="string">'skey2'</span>)</div><div class="line">&#123;<span class="string">b'd'</span>, <span class="string">b'a'</span>, <span class="string">b'f'</span>, <span class="string">b'e'</span>, <span class="string">b'c'</span>, <span class="string">b'b'</span>&#125;</div></pre></td></tr></table></figure></p>
<p>和Python的集合相比，Redis的集合除了可以被多个客户端远程地进行访问之外，其他的语义和功能基本都是相同的。</p>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a><strong>散列</strong></h3><p>首先介绍一些常用的添加和删除键值对的Redis散列命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>HMGET</td>
<td>HMGET key field [field …]</td>
<td>返回key指定的散列中指定字段的值</td>
<td>hmget(name, keys, *args)</td>
</tr>
<tr>
<td>HMSET</td>
<td>HMSET key field value [field value …]</td>
<td>设置key指定的散列中指定字段的值，该命令将重写所有在散列中存在的字段，如果key指定的散列不存在，会创建一个新的散列并与key关联</td>
<td>hmset(name, mapping)</td>
</tr>
<tr>
<td>HDEL</td>
<td>HDEL key field [field …]</td>
<td>从key指定的散列中移除指定的域，在散列中不存在的域将被忽略，如果key指定的散列不存在，它将被认为是一个空的散列，该命令将返回0</td>
<td>hdel(name, *keys)</td>
</tr>
<tr>
<td>HLEN</td>
<td>HLEN key</td>
<td>返回key指定的散列包含的字段的数量</td>
<td>hlen(name)</td>
</tr>
</tbody>
</table>
<p>其中，HDEL命令已经介绍过了，而HLEN以及用于一次读取或设置多个键的HMGET和HMSET则是新出现的命令。它们既可以给用户带来方便，又可以通过减少命令的调用次数以及客户端与Redis之间的通信往返次数来提升Redis的性能。</p>
<p>下面这个交互示例展示了这些命令的使用方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hmset(<span class="string">'hash-key'</span>, &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hmget(<span class="string">'hash-key'</span>, [<span class="string">'k2'</span>, <span class="string">'k3'</span>])</div><div class="line">[<span class="string">b'v2'</span>, <span class="string">b'v3'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hlen(<span class="string">'hash-key'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hdel(<span class="string">'hash-key'</span>, <span class="string">'k1'</span>, <span class="string">'k3'</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>之前的学习笔记(一)介绍的HGET命令和HSET命令分别是HMGET和HMSET命令的单参数版本。因为HDEL已经可以同时删除多个键值对了，所以Redis没有实现HMDEL命令。</p>
<p>下表列出了散列的其他几个批量操作命令，以及一些和字符串操作类似的散列命令。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEXISTS</td>
<td>HEXISTS key field</td>
<td>检查给定键是否存在于散列中</td>
<td>hexists(name, key)</td>
</tr>
<tr>
<td>HKEYS</td>
<td>HKEYS key</td>
<td>返回散列包含的所有键</td>
<td>hkeys(name)</td>
</tr>
<tr>
<td>HVALS</td>
<td>HVALS key</td>
<td>返回散列包含的所有值</td>
<td>hvals(name)</td>
</tr>
<tr>
<td>HGETALL</td>
<td>HGETALL key</td>
<td>返回散列包含的所有键值对</td>
<td>hgetall(name)</td>
</tr>
<tr>
<td>HINCRBY</td>
<td>HINCRBY key field increment</td>
<td>将键存储的值加上整数increment</td>
<td>hincrby(name, key, amount=1)</td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td>HINCRBYFLOAT key field increment</td>
<td>将键存储的值加上浮点数increment</td>
<td>hincrbyfloat(name, key, amount=1.0)</td>
</tr>
</tbody>
</table>
<p>下面这个交互示例展示了这些命令的使用方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hmset(<span class="string">'hash-key2'</span>, &#123;<span class="string">'short'</span>:<span class="string">'hello'</span>, <span class="string">'long'</span>:<span class="number">1000</span>*<span class="number">1</span>&#125;)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hkeys(<span class="string">'hash-key2'</span>)</div><div class="line">[<span class="string">b'short'</span>, <span class="string">b'long'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hexists(<span class="string">'hash-key2'</span>, <span class="string">'num'</span>)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hincrby(<span class="string">'hash-key2'</span>, <span class="string">'num'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.hexists(<span class="string">'hash-key2'</span>, <span class="string">'num'</span>)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>在对散列进行处理时，如果键值对的值的体积非常大，那么用户可以先用HKEYS获取散列的所有键，然后只获取必要的值，这样可以有效地减少需要传输的数据量，避免服务器阻塞。</p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a><strong>有序集合</strong></h3><p>下表展示了一些常用的有序集合命令，大部分在第一章都有介绍</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>ZADD key score member [score member …]</td>
<td>将带有给定分值的成员添加到有序集合中</td>
<td>zadd(name, <em>args, *</em>kwargs)</td>
</tr>
<tr>
<td>ZREM</td>
<td>ZREM key member [member …]</td>
<td>移除给定的成员，并返回被移除成员的数量</td>
<td>zrem(name, *values)</td>
</tr>
<tr>
<td>ZCARD</td>
<td>ZCARD key</td>
<td>返回有序集合包含的成员数量</td>
<td>zcard(name)</td>
</tr>
<tr>
<td>ZINCRBY</td>
<td>ZINCRBY key increment member</td>
<td>将member成员的分值加上increment</td>
<td>zincrby(name, value, amount=1)</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>ZCOUNT key min max</td>
<td>返回分值介于min和max之间的成员数量</td>
<td>zcount(name, min, max)</td>
</tr>
<tr>
<td>ZRANK</td>
<td>ZRANK key member</td>
<td>返回成员member在有序集合中的排名</td>
<td>zrank(name, value)</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>ZSCORE key member</td>
<td>返回成员member的分值</td>
<td>zscore(name, value)</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>返回排名介于start和stop之间的成员，如果给定了可选的WITHSCORES选项，那么命令会将成员的分值也一并返回</td>
<td>zrange(name, start, end, desc=False, withscores=False, score_cast_func=<class 'float'="">)</class></td>
</tr>
</tbody>
</table>
<p>下面这个交互示例展示了Redis中的一些常用的有序集合命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zadd(<span class="string">'zset-key'</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="number">1</span>, <span class="string">'c'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zcard(<span class="string">'zset-key'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zincrby(<span class="string">'zset-key'</span>, <span class="string">'c'</span>, <span class="number">3</span>)</div><div class="line"><span class="number">4.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zscore(<span class="string">'zset-key'</span>, <span class="string">'b'</span>)</div><div class="line"><span class="number">2.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zrank(<span class="string">'zset-key'</span>, <span class="string">'c'</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zcount(<span class="string">'zset-key'</span>, <span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zrem(<span class="string">'zset-key'</span>, <span class="string">'b'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zrange(<span class="string">'zset-key'</span>, <span class="number">0</span>, <span class="number">-1</span>, withscores=<span class="keyword">True</span>)</div><div class="line">[(<span class="string">b'a'</span>, <span class="number">3.0</span>), (<span class="string">b'c'</span>, <span class="number">4.0</span>)]</div></pre></td></tr></table></figure></p>
<p>其中在Python客户端用StrictRedis客户端类执行ZADD命令需要先输入分值，再输入成员，这也是Redis的标准，而Redis客户端类则截然相反。</p>
<p>下表展示了另外一下非常有用的有序集合命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例</th>
<th>描述</th>
<th>redis-py API</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZREVRANK</td>
<td>ZREVRANK key member</td>
<td>返回有序集合里成员member的排名，成员按照分值从大到小排列</td>
<td>zrevrank(name, value)</td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td>
<td>zrevrange(name, start, end, withscores=False, score_cast_func=<class 'float'="">)</class></td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td>
<td>返回有序集合中指定分数区间内的成员</td>
<td>zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=<class 'float'="">)</class></td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE</td>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count]</td>
<td>返回有序集合中指定分数区间内的成员，分数由高到低排序。</td>
<td>zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=<class 'float'="">)</class></td>
</tr>
<tr>
<td>ZREMRANGEBYRANK</td>
<td>ZREMRANGEBYRANK key start stop</td>
<td>移除有序集key中，指定排名(rank)区间内的所有成员</td>
<td>zremrangebyrank(name, min, max)</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE</td>
<td>ZREMRANGEBYSCORE key min max</td>
<td>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员</td>
<td>zremrangebyscore(name, min, max)</td>
</tr>
<tr>
<td>ZINTERSTORE</td>
<td>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM</td>
<td>MIN</td>
<td>MAX]</td>
<td>计算给定的numkeys个有序集合的交集，并且把结果放到destination中</td>
<td>zinterstore(dest, keys, aggregate=None)</td>
</tr>
<tr>
<td>ZUNIONSTORE</td>
<td>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM</td>
<td>MIN</td>
<td>MAX]</td>
<td>计算给定的numkeys个有序集合的并集，并且把结果放到destination中。</td>
<td>zunionstore(dest, keys, aggregate=None)</td>
</tr>
</tbody>
</table>
<p>其中有几个是没有介绍过的新命令，除了使用逆序来处理有序集合之外，ZREV*命令的工作方式和相对应的非逆序命令的工作方式完全一样(逆序就是指元素按照分值从大到小地排列)。</p>
<p>下面这个交互示例展示了ZINTERSTORE和ZUNIONSTORE命令的用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zadd(<span class="string">'zset-1'</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zadd(<span class="string">'zset-2'</span>, <span class="number">4</span>, <span class="string">'b'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">0</span>, <span class="string">'d'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zinterstore(<span class="string">'zset-i'</span>, [<span class="string">'zset-1'</span>, <span class="string">'zset-2'</span>])</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zrange(<span class="string">'zset-i'</span>, <span class="number">0</span>, <span class="number">-1</span>, withscores=<span class="keyword">True</span>)</div><div class="line">[(<span class="string">b'c'</span>, <span class="number">4.0</span>), (<span class="string">b'b'</span>, <span class="number">6.0</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zunionstore(<span class="string">'zset-u'</span>, [<span class="string">'zset-1'</span>, <span class="string">'zset-2'</span>], aggregate=<span class="string">'min'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zrange(<span class="string">'zset-u'</span>, <span class="number">0</span>, <span class="number">-1</span>, withscores=<span class="keyword">True</span>)</div><div class="line">[(<span class="string">b'd'</span>, <span class="number">0.0</span>), (<span class="string">b'a'</span>, <span class="number">1.0</span>), (<span class="string">b'c'</span>, <span class="number">1.0</span>), (<span class="string">b'b'</span>, <span class="number">2.0</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.sadd(<span class="string">'set-1'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zunionstore(<span class="string">'zset-u2'</span>, [<span class="string">'zset-1'</span>, <span class="string">'zset-2'</span>, <span class="string">'set-1'</span>])</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.zrange(<span class="string">'zset-u2'</span>, <span class="number">0</span>, <span class="number">-1</span>, withscores=<span class="keyword">True</span>)</div><div class="line">[(<span class="string">b'd'</span>, <span class="number">1.0</span>), (<span class="string">b'a'</span>, <span class="number">2.0</span>), (<span class="string">b'c'</span>, <span class="number">4.0</span>), (<span class="string">b'b'</span>, <span class="number">6.0</span>)]</div></pre></td></tr></table></figure></p>
<p>用户可以在执行交并运算时传入不同的聚合函数，共有sum、min、max三种可选；用户还可以把集合作为输入传给ZINTERSTORE和ZUNIONSTORE，命令会将集合看作是成员分值全为1的有序集合来处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redis-py简介&quot;&gt;&lt;a href=&quot;#redis-py简介&quot; class=&quot;headerlink&quot; title=&quot;redis-py简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;redis-py简介&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在之前的学习笔记(一)中已经安装过&lt;a href=&quot;https://github.com/andymccurdy/redis-py&quot;&gt;redis-py&lt;/a&gt;，我的Python版本是3.5.2&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis, Python" scheme="http://yoursite.com/tags/Redis-Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记(一)：初识Redis</title>
    <link href="http://yoursite.com/2017/03/25/Redis-1/"/>
    <id>http://yoursite.com/2017/03/25/Redis-1/</id>
    <published>2017-03-25T12:18:54.000Z</published>
    <updated>2017-03-27T09:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a><strong>Redis简介</strong></h2><p>Redis是一个速度极快的非关系数据库，也就是我们所说的NoSQL数据库(non-relational database)，它可以存储键(key)与5种不同类型的值(value)之间的映射(mapping)，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展性能，并且它还提供了多种语言的API。<br><a id="more"></a></p>
<h2 id="Redis与memcached及其他类型数据库对比"><a href="#Redis与memcached及其他类型数据库对比" class="headerlink" title="Redis与memcached及其他类型数据库对比"></a><strong>Redis与memcached及其他类型数据库对比</strong></h2><p>Redis经常被拿来与memcached进行比较，两者都可用于存储键值映射，性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，而且Redis除了能存储普通的字符串键，还能存储其他4种数据结构，使得Redis可以用于解决更为广泛的问题，并且即可以作为主数据库使用，又可以作为其他存储系统的辅助数据库。</p>
<p>下表展示了Redis与memcached，MySQL以及MongoDB的特性与功能。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数据存储选项</th>
<th>查询类型</th>
<th>附加功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis</td>
<td>使用内存存储的非关系数据库</td>
<td>字符串、列表、集合、散列表、有序集合</td>
<td>每种数据类型专属的命令，以及批量操作和不完全的事务支持</td>
<td>发布与订阅，主从复制，持久化，脚本</td>
</tr>
<tr>
<td>memcached</td>
<td>使用内存存储的键值缓存</td>
<td>键值之间的映射</td>
<td>创建、读取、删除、更新等命令</td>
<td>多线程服务器，用于提升性能</td>
</tr>
<tr>
<td>MySQL</td>
<td>关系数据库</td>
<td>每个数据库可以包含多个表，每个表可以包含多个行；可以处理多个表的视图；支持空间和第三方扩展</td>
<td>SELECT、INSERT、UPDATE、DELETE、函数、存储过程</td>
<td>支持ACID性质(需要使用InnoDB)，主从复制，主主复制</td>
</tr>
<tr>
<td>MongoDB</td>
<td>使用硬盘存储(on-disk)的非关系文档存储</td>
<td>每个数据库可以包含多个表，每个表可以包含多个无schema的BSON文档</td>
<td>创建、读取、更新、删除、条件查询等命令</td>
<td>支持map-reduce操作，主从复制，分片，空间索引</td>
</tr>
</tbody>
</table>
<h2 id="Redis安装-mac"><a href="#Redis安装-mac" class="headerlink" title="Redis安装(mac)"></a><strong>Redis安装(mac)</strong></h2><p>首先下载用于安装Rudix的引导脚本，并安装Rudix<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -O http://rudix.google.code.com/hg/Ports/rudix/rudix.Py</div><div class="line">$ sudo python rudix.py install rudix</div></pre></td></tr></table></figure></p>
<p>然后使用命令Rudix安装Redis，若能成功启动Redis服务器则安装成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo rudix install redis</div><div class="line">$ redis-server</div></pre></td></tr></table></figure></p>
<p>最后用pip为Python安装Redis客户端库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install redis</div></pre></td></tr></table></figure></p>
<h2 id="Redis数据结构简介"><a href="#Redis数据结构简介" class="headerlink" title="Redis数据结构简介"></a><strong>Redis数据结构简介</strong></h2><p>Redis可以存储键与5种不同数据结构类型之间的映射，分别是STRING(字符串)、LIST(列表)、SET(集合)、HASH(散列)、ZSET(有序集合)。有一部分命令对于这5种数据结构是通用的，如DEL、TYPE、RENAME等；但也有一部分命令只能对特定的一种或者两种结构使用。</p>
<p>下表从结构存储的值及读写能力对比了Redis的5种数据结构。</p>
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数进行自增或自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表两端推入或弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或多个元素；根据值查找或移除元素</td>
</tr>
<tr>
<td>SET</td>
<td>包含字符串的无序收集器，并且被包含的每个字符串互不相同</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；获取所有键值对</td>
</tr>
<tr>
<td>ZSET</td>
<td>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h3 id="Redis字符串"><a href="#Redis字符串" class="headerlink" title="Redis字符串"></a><strong>Redis字符串</strong></h3><p>下表展示了3种简单的字符串命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取存储在给定键中的值</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定键中的值</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定键中的值(该命令可用于所有类型)</td>
</tr>
</tbody>
</table>
<p>SET、GET、DEL的使用示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; get hello</div><div class="line"><span class="string">"world"</span></div><div class="line">127.0.0.1:6379&gt; del hello</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; get hello</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>SET命令在执行成功时返回OK，Python客户端会将这个OK转换为True；DEL命令在执行成功时将会返回被成功删除的值的数量；GET命令在尝试得到不存在的值时，将会返回一个nil，Python客户端会将这个nil转换为None。</p>
<h3 id="Redis列表"><a href="#Redis列表" class="headerlink" title="Redis列表"></a><strong>Redis列表</strong></h3><p>下表展示了6种简单的列表命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPUSH(RPUSH)</td>
<td>将给定值推入列表的左端(右端)</td>
</tr>
<tr>
<td>LPOP(RPOP)</td>
<td>从列表的左端(右端)弹出一个值，并返回被弹出的值</td>
</tr>
<tr>
<td>LINDEX</td>
<td>获取列表在给定位置上的单个值</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表在给定范围上的所有值</td>
</tr>
</tbody>
</table>
<p>RPUSH、LRANGE、LINDEX、LPOP的使用示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">127.0.0.1:6379&gt; rpush list-key item</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; rpush list-key item2</div><div class="line">(<span class="built_in">integer</span>) 2</div><div class="line">127.0.0.1:6379&gt; rpush list-key item</div><div class="line">(<span class="built_in">integer</span>) 3</div><div class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</div><div class="line">1) <span class="string">"item"</span></div><div class="line">2) <span class="string">"item2"</span></div><div class="line">3) <span class="string">"item"</span></div><div class="line">127.0.0.1:6379&gt; lindex list-key 1</div><div class="line"><span class="string">"item2"</span></div><div class="line">127.0.0.1:6379&gt; lpop list-key </div><div class="line"><span class="string">"item"</span></div><div class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</div><div class="line">1) <span class="string">"item2"</span></div><div class="line">2) <span class="string">"item"</span></div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>RPUSH和LPUSH命令在执行成功后会返回当前列表的长度；列表索引范围从0开始，到-1结束，可以取出列表包含的所有元素；使用LINDEX可以从列表中取出单个元素。</p>
<h3 id="Redis集合"><a href="#Redis集合" class="headerlink" title="Redis集合"></a><strong>Redis集合</strong></h3><p>Redis的集合和列表都可以存储多个字符串，它们的不同之处在于，列表可以存储多个相同的字符串，而集合则通过散列表来保证自己存储的每个字符串都是不同的(这些散列表只有键)。</p>
<p>下表展示了6种简单的集合命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>将给定元素添加到集合</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合包含的所有元素</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>检查给定元素是否存在于集合中</td>
</tr>
<tr>
<td>SREM</td>
<td>如果给定的元素存在于集合中，那么移除这个元素</td>
</tr>
</tbody>
</table>
<p>SADD、SMEMBERS、SISMEMBER、SREM的使用示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span>-key item</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span>-key item2</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span>-key item3</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span>-key item</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span>-key</div><div class="line">1) <span class="string">"item2"</span></div><div class="line">2) <span class="string">"item3"</span></div><div class="line">3) <span class="string">"item"</span></div><div class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span>-key item4</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span>-key item</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span>-key item2</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span>-key item2</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span>-key</div><div class="line">1) <span class="string">"item3"</span></div><div class="line">2) <span class="string">"item"</span></div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>SADD命令返回1表示成功添加到集合中，返回0表示该元素已存在于集合中；SMEMBERS命令获取到的元素组成的序列将会被Python客户端转换为Python集合；Python客户端会返回一个布尔值来表示SISMEMBER命令的检查结果；SREM命令会返回被移除元素的数量。</p>
<h3 id="Redis散列"><a href="#Redis散列" class="headerlink" title="Redis散列"></a><strong>Redis散列</strong></h3><p>Redis的散列就像一个微型Redis，它可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串也可以是数值。可以将散列看做文档数据库里面的文档，还可以看做是关系数据库里面的行，因为散列、文档和行都允许用户同时访问或修改一个或多个域(field)。</p>
<p>下表展示了4种简单的列表命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>在散列里面关联给定的键值对</td>
</tr>
<tr>
<td>HGET</td>
<td>获取指定散列键的值</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取散列包含的所有键值对</td>
</tr>
<tr>
<td>HDEL</td>
<td>如果给定键存在于散列里面，那么移除这个键</td>
</tr>
</tbody>
</table>
<p>HSET、HGET、HGETALL、HDEL的使用示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">127.0.0.1:6379&gt; hset <span class="built_in">hash</span>-key sub-key1 value1</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; hset <span class="built_in">hash</span>-key sub-key2 value2</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; hset <span class="built_in">hash</span>-key sub-key1 value1</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; hgetall <span class="built_in">hash</span>-key</div><div class="line">1) <span class="string">"sub-key1"</span></div><div class="line">2) <span class="string">"value1"</span></div><div class="line">3) <span class="string">"sub-key2"</span></div><div class="line">4) <span class="string">"value2"</span></div><div class="line">127.0.0.1:6379&gt; hdel <span class="built_in">hash</span>-key sub-key2</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; hdel <span class="built_in">hash</span>-key sub-key2</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; hget <span class="built_in">hash</span>-key sub-key1</div><div class="line"><span class="string">"value1"</span></div><div class="line">127.0.0.1:6379&gt; hgetall <span class="built_in">hash</span>-key</div><div class="line">1) <span class="string">"sub-key1"</span></div><div class="line">2) <span class="string">"value1"</span></div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>HSET返回一个值来表示给定的键是否已经存在于散列里面；Python客户端会把HGETALL命令获取的整个散列转换为一个Python字典；HDEL命令执行后会返回一个值来表示给定的键在移除之前是否存在于散列里面。</p>
<h3 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a><strong>Redis有序集合</strong></h3><p>有序集合和散列一样，都用于存储键值对：其中有序集合的每个键称为成员（member），都是独一无二的，而有序集合的每个值称为分值（score），都必须是浮点数。有序集合是Redis里面唯一既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。</p>
<p>下表展示了4种简单的有序集合命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>将一个带有给定分值的成员添加到有序集合里面</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据元素在有序排列中所处的位置，从有序集合里获取多个元素</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>获取有序集合在给定分值范围内的所有元素</td>
</tr>
<tr>
<td>ZREM</td>
<td>如果给定成员存在于有序集合，那么移除这个成员</td>
</tr>
</tbody>
</table>
<p>ZADD、ZRANGE、ZRANGEBYSCORE、ZREM的使用示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">127.0.0.1:6379&gt; zadd zset-key 728 member1</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</div><div class="line">1) <span class="string">"member1"</span></div><div class="line">2) <span class="string">"728"</span></div><div class="line">3) <span class="string">"member0"</span></div><div class="line">4) <span class="string">"982"</span></div><div class="line">127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores</div><div class="line">1) <span class="string">"member1"</span></div><div class="line">2) <span class="string">"728"</span></div><div class="line">127.0.0.1:6379&gt; zrem zset-key member1</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">127.0.0.1:6379&gt; zrem zset-key member1</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</div><div class="line">1) <span class="string">"member0"</span></div><div class="line">2) <span class="string">"982"</span></div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>在尝试向有序集合添加元素的时候，ZADD命令会返回新添加元素的数量；ZRANGE命令获取有序集合包含的所有元素，这些元素会按照分值进行排序，Python客户端会将这些分值转换成浮点数；ZRANGEBYSCORE命令也可以根据分值来获取有序集合的其中一部分元素；ZREM命令在移除有序集合元素的时候，命令会返回被移除元素的数量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;Redis简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Redis是一个速度极快的非关系数据库，也就是我们所说的NoSQL数据库(non-relational database)，它可以存储键(key)与5种不同类型的值(value)之间的映射(mapping)，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展性能，并且它还提供了多种语言的API。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis, Python" scheme="http://yoursite.com/tags/Redis-Python/"/>
    
  </entry>
  
</feed>
