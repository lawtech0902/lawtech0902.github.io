<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Redis学习笔记(四)：数据安全与性能保障——持久化]]></title>
      <url>%2F2017%2F04%2F09%2FRedis-4%2F</url>
      <content type="text"><![CDATA[什么是持久化？持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 我们这样理解：在一定周期内保持不变就是持久化，持久化是针对时间来说的。数据库中的数据就是持久化了的数据，只要你不去删除或修改。 持久化选项Redis提供了两种不同的持久化方法来将数据存储到硬盘中，保证数据在Redis重启后仍然存在： RDB持久化：在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot），也就是将存在于某一时刻的所有数据都写入硬盘里面，所以也叫作快照持久化。 AOF持久化：全称是 append-only file（只追加文件）， 它记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。 这两种持久化的方式既可以单独使用，也可以同时使用，具体选择哪种方式需要根据用户的数据及应用进行选择。 下面的代码示例展示了Redis对于两种持久化选项提供的配置选项 1234567891011121314# 快照持久化选项save 60 1000 # 60秒内有1000次写入操作的时候执行快照的创建stop-writes-on-bgsave-error no # 创建快照失败的时候是否仍然继续执行写命令rdbcompression yes # 是否对快照文件进行压缩dbfilename dump.rdb # 如何命名硬盘上的快照文件dir ./ # 快照所保存的位置# AOF持久化选项appendonly no # 是否使用AOF持久化appendfsync everysec # 多久才将写入的内容同步到硬盘no-appendfsync-on-rewrite no # 在对AOF进行压缩(compaction)的时候能否执行同步操作auto-aof-rewrite-percentage 100 # 多久执行一次AOF压缩auto-aof-rewrite-min-size 64mb # 多久执行一次AOF压缩dir ./ # AOF所保存的位置 快照持久化（RDB）创建快照的办法 客户端通过向Redis发送BGSAVE命令来创建快照。 如果平台支持（除了Windows），那么Redis会调用fork来创建一个子进程，然后子进程负责将快照写到硬盘中，而父进程则继续处理命令请求。 使用场景： 如果用户使用了save设置，例如：save 60 1000 ,那么从Redis最近一次创建快照之后开始计算，当“60秒之内有1000次写入操作”这个条件满足的时候，Redis就会自动触发BGSAVE命令。 如果用户使用了多个save设置，那么当任意一个save配置满足条件的时候，Redis都会触发一次BGSAVE命令。 客户端通过向Redis发SAVE命令来创建快照。 接收到SAVE命令的Redis服务器在快照创建完毕之前将不再响应任何其他命令的请求。SAVE命令并不常用，我们通常只在没有足够的内存去执行BGSAVE命令的时候才会使用SAVE命令，或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。 使用场景： 当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准的TERM信号时，会执行一次SAVE命令，阻塞所有的客户端，不再执行客户端发送的任何命令，并且在执行完SAVE命令之后关闭服务器。 优点 RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次快照文件，并且在每个月的每一天，也备份一个快照文件。 这样的话，即使遇到问题，也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。 RDB 可以最大化 Redis 的性能：父进程在保存快照文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 缺点 如果在新的快照文件创建好之前，Redis、系统、硬件三者中任意一个发生崩溃，那么Redis将丢失最近一次创建快照之后写入的所有数据。如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork()可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。 AOF持久化AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。这样，我们在恢复数据的时候，只需要从头到尾的执行一下AOF文件即可恢复数据。 我们可以通过appendonly yes命令来打开AOF持久化选项 appendfsync同步频率下表展示了appendfsync选项对AOF文件的同步频率的影响 选项 同步频率 always 每个Redis写命令都要同步写入硬盘。这样做会严重降低Redis的速度 everysec 每秒执行一次同步，显示地将多个写命令同步到硬盘 no 让操作系统来决定应该何时进行同步 always的方式固然可以对没一条数据进行很好的保存，但是这种同步策略需要对硬盘进行大量的写操作，所以Redis处理命令的速度会受到硬盘性能的限制。 普通的硬盘每秒钟只能处理大约200个写命令，使用固态硬盘SSD每秒可以处理几万个写命令，但是每次只写一个命令，这种只能怪不断地写入很少量的数据的做法有可能引发严重的写入放大问题，这种情况下降严重影响固态硬盘的使用寿命。 everysec的方式，Redis以每秒一次的频率大队AOF文件进行同步。这样的话既可以兼顾数据安全也可以兼顾写入性能。 Redis以每秒同步一次AOF文件的性能和不使用任何持久化特性时的性能相差无几，使用每秒更新一次 的方式，可以保证，即使出现故障，丢失的数据也在一秒之内产生的数据。 no的方式，Redis将不对AOF文件执行任何显示的同步操作，而是由操作系统来决定应该何时对AOF文件进行同步。 这个命令一般不会对Redis的性能造成多大的影响，但是当系统出现故障的时候使用这种选项的Redis服务器丢失不定数量的数据。 另外，当用户的硬盘处理写入操作的速度不够快的话，那么缓冲区被等待写入硬盘的数据填满时，Redis的写入操作将被阻塞，并导致Redis处理命令请求的速度变慢，因为这个原因，一般不推荐使用这个选项。 重写/压缩AOF文件随着数据量的增大，AOF的文件可能会很大，这样在每次进行数据恢复的时候就会进行很长的时间，为了解决日益增大的AOF文件，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，是AOF文件的体积变得尽可能的小。 BGREWRITEAOF的工作原理和BGSAVE的原理很像：Redis会创建一个子进程，然后由子进程负责对AOF文件的重写操作。 因为AOF文件重写的时候会创建子进程，所以快照持久化因为创建子进程而导致的性能和内存占用问题同样会出现在AOF文件重写的时候。 跟快照持久化通过save选项来自动执行BGSAVE一样，AOF通过设置auto-aof-rewrite-percentage和auto-aof-rewrite-min-size选项来自动执行BGREWRITEAOF。 如下配置 12auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 表示当前AOF的文件体积大于64MB，并且AOF文件的体积比上一次重写之后的体积变大了至少一倍（100%）的时候，Redis将执行重写BGREWRITEAOF命令。 如果AOF重写执行的过于频繁的话，可以将auto-aof-rewrite-percentage选项的值设置为100以上，这种最偶发就可以让Redis在AOF文件的体积变得更大之后才执行重写操作，不过，这也使得在进行数据恢复的时候执行的时间变得更加长一些。 优点 使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。 AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。 如何选择RDB和AOF？一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。 RDB 和 AOF 之间的相互作用BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。 这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。 如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户，BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。 当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MxOnline项目学习总结]]></title>
      <url>%2F2017%2F04%2F07%2FMxOnline-summary%2F</url>
      <content type="text"><![CDATA[拖拖拉拉地学完了imooc的”强力django+杀手级xadmin打造上线标准的在线教育平台”课程，记录一下每一章学习的内容概要。 MxOnline项目学习总结第一、二章 课程介绍 开发环境搭建 第三章 django基础回顾 settings.py 设置 urls.py 配置 models.py 设计 views.py 编码 templates 模板编码 第四章 数据库设计 users app model 设计 organization app model 设计 course app model 设计 operation app model 设计 第五章 后台管理系统开发 django admin 介绍 xadmin 安装和 model 注册 xadmin 全局配置 第六章 登录、注册、找回密码 登录（ session 和 cookie 机制） 注册（ form 表单提交、图片验证码，发送邮件 ） 找回密码（邮件发送） 第七章 课程机构功能实现 机构列表（分页，筛选、排序） 机构详情页（收藏，富文本展示） 咨询提交（ modelform 验证和保存） 第八章 课程功能实现 课程列表（分页、排序） 课程详情页（收藏，章节展示、资源展示、评论） 第九章 讲师功能实现 讲师列表（分页、排序） 讲师详情（收藏） 第十章 个人中心功能实现 用户信息修改（修改密码、头像、邮箱、基本信息） 导航栏全局搜索功能 我的课程 我的收藏（删除收藏） 我的消息 第十一章 全局功能实现 全局404和500页面配置 首页开发 点击数和收藏数修改和退出功能 第十二章 常见 web 攻击 sql 注入攻击 xss 攻击 csrf 攻击 第十三章 xadmin 进阶开发 userprofile 注册和设置 xadmin 常见功能设置 inlinemodel 注册、proxy 代理注册 django ueditor 富文本编辑器继承 excel 导入插件集成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis学习笔记(三)：Redis命令补充]]></title>
      <url>%2F2017%2F04%2F06%2FRedis-3%2F</url>
      <content type="text"><![CDATA[在之前的学习笔记中，还有许多Redis的命令没有涉及，这一篇主要用来简要地补充，当然，详细的命令还得参考Redis的官方命令文档。 键值相关命令下表展示了Redis提供的一些键值(KEY-VALUE)相关的常用命令及其redis-py API 命令 用例 描述 redis-py API KEYS KEYS pattern 查找所有符合给定模式pattern(正则表达式)的key keys(pattern=’*’) EXISTS EXISTS key 检查给定key是否存在 exists(name) EXPIRE EXPIRE key seconds 为给定key设置生存时间，当key过期时(生存时间为0)，它会被自动删除 expire(name, time) MOVE MOVE key db 将当前数据库的key移动到给定的数据库db当中 move(name, db) PERSIST PERSIST key 移除给定key的生存时间，将这个key从『易失的』(带生存时间key)转换成『持久的』(一个不带生存时间、永不过期的key) persist(name) RANDOMKEY RANDOMKEY 从当前数据库返回一个随机的key randomkey() RENAME RENAME key newkey 将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖 rename(src, dst) TYPE TYPE key 返回key所存储的value的数据结构类型，它可以返回string, list, set, zset和hash等不同的类型 type(name) TTL TTL key 返回key剩余的过期时间(单位：秒) ttl(name) 下面这个交互示例展示了Redis中关于键的过期时间相关的命令的使用方法 12345678910111213&gt;&gt;&gt; r.set('key', 'value')True&gt;&gt;&gt; r.get('key')b'value'&gt;&gt;&gt; r.expire('key', 2)True&gt;&gt;&gt; time.sleep(2)&gt;&gt;&gt; r.get('key')&gt;&gt;&gt; r.set('key', 'value2')True&gt;&gt;&gt; r.expire('key', 100); r.ttl('key')True100 发布与订阅发布订阅(pub/sub)是一种消息通信模式，主要的目的是解耦消息发布者和消息订阅者之间的耦合，这点和设计模式中的观察者模式比较相似。pub/sub不仅仅解决发布者和订阅者之间代码级别耦合也解决两者在物理部署上的耦合。Redis作为一个pub/sub的server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向 redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道(channel)。当发布者通过publish命令向 redis server发送二进制字符串消息(binary string message)时，订阅该消息类型的全部client都会收到此消息。这里消息的传递是多对多的，一个client可以订阅多个channel，也可以向多个channel发送消息。 下表展示了Redis提供的发布与订阅命令及其redis-py API 命令 用例 描述 redis-py API SUBSCRIBE SUBSCRIBE channel [channel …] 订阅给定的频道 subscribe(args, *kwargs) UNSUBSCRIBE UNSUBSCRIBE [channel [channel …]] 退订给定的频道，如果没有给定任何频道，则退订所有频道 unsubscribe(*args) PUBLISH PUBLISH channel message 将信息message发送到指定的频道channel publish(channel, message) PSUBSCRIBE PSUBSCRIBE pattern [pattern …] 订阅与给定模式相关的频道 psubscribe(args, *kwargs) PUNSUBSCRIBE PUNSUBSCRIBE [pattern [pattern …]] 退订给定的模式，如果没有给定，则退订所有模式 PUNSUBSCRIBE [pattern [pattern …]] PUBSUB PUBSUB subcommand [argument [argument …]] PUBSUB命令是一个introspection命令，允许检查Pub/Sub子系统的状态，它由单独记录的子命令组成 pubsub(**kwargs) 考虑到PUBLISH命令和SUBSCRIBE命令在Python客户端的实现方式，一个比较简单的延时发布与订阅的方法，就是像如下代码那样用辅助线程(helper thread)来执行PUBLISH命令 1234567891011121314151617181920212223242526import redisimport timeimport threadingpool = redis.ConnectionPool(host='localhost', port=6379, db=0)r = redis.StrictRedis(connection_pool=pool)def publisher(n): time.sleep(1) for i in range(n): r.publish('channel', i)def run_pubsub(): threading.Thread(target=publisher, args=(3,)).start() pubsub = r.pubsub() pubsub.subscribe(['channel']) count=0 for item in pubsub.listen(): print(item) count += 1 if count == 4: pubsub.unsubscribe() if count == 5: break publisher函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。在发布消息之后进行短暂的休眠，让消息可以一条接一条地出现。 run_pubsub函数启动发送者线程，让它发送三条消息。随后创建发布与订阅对象，并让它订阅给定的频道。通过遍历函数pubsub.listen()的执行结果来监听订阅消息。在接收到一条订阅反馈消息和三条发布者发送的消息之后，执行退订操作，停止监听新消息。客户端在接收到退订反馈消息之后，就不再接收消息。 实际运行函数并观察它们的行为123456&gt;&gt;&gt; run_pubsub()&#123;'type': 'subscribe', 'channel': b'channel', 'data': 1, 'pattern': None&#125;&#123;'type': 'message', 'channel': b'channel', 'data': b'0', 'pattern': None&#125;&#123;'type': 'message', 'channel': b'channel', 'data': b'1', 'pattern': None&#125;&#123;'type': 'message', 'channel': b'channel', 'data': b'2', 'pattern': None&#125;&#123;'type': 'unsubscribe', 'channel': b'channel', 'data': 0, 'pattern': None&#125; 以上这些结构就是我们在遍历pubsub.listen()函数时得到的元素。 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。在退订频道时，客户端会接收到一条反馈消息，告知被退订的是哪一个频道，以及客户端目前仍在订阅的频道数量。 其他命令排序Redis中负责执行排序操作的SORT命令可以根据字符串、列表、集合、有序集合、散列这5中键里面存储的数据，对列表、集合以及有序集合进行排序，可以将SORT命令看作是SQL语言中的order by子句。 下表展示了SORT命令的定义及其redis-py API 命令 用例 描述 redis-py API SORT SORT key [BY pattern][LIMIT offset count] [GET pattern][ASC\ DESC] [ALPHA] destination 返回或存储key的list、set或sorted set中的元素。默认是按照数值类型排序的，并且按照两个元素的双精度浮点数类型值进行比较 sort(name, start=None, num=None, by=None, get=None, desc=False, alpha=False, store=None, groups=False) 下面展示了SORT命令的一些简单的用法123456789101112131415161718&gt;&gt;&gt; r.rpush('sort-input', 23, 15, 110, 7)4&gt;&gt;&gt; r.sort('sort-input')[b'7', b'15', b'23', b'110']&gt;&gt;&gt; r.sort('sort-input', alpha=True)[b'110', b'15', b'23', b'7']&gt;&gt;&gt; r.hset('d-7', 'field', 5)1&gt;&gt;&gt; r.hset('d-15', 'field', 1)1&gt;&gt;&gt; r.hset('d-23', 'field', 9)1&gt;&gt;&gt; r.hset('d-110', 'field', 3)1&gt;&gt;&gt; r.sort('sort-input', by='d-*-&gt;field')[b'15', b'110', b'7', b'23']&gt;&gt;&gt; r.sort('sort-input', by='d-*-&gt;field', get='d-*-&gt;field')[b'1', b'3', b'5', b'9'] SORT命令不仅可以对列表进行排序，还可以对集合进行排序，然后返回一个列表形式的排序结果。上述代码除了展示如何使用alpha关键字(根据元素字母表顺序，默认根据大小)参数对元素进行字符串排序之外，还展示了如何基于外部数据对元素进行排序，以及如何获取并返回外部数据。 尽管SORT是Redis中唯一一个可以同时处理3种不同类型的数据的命令，但是事务同样可以让我们在一连串不间断执行的命令里面操作不同类型的数据。 基本的Redis事务Redis中的事务(transaction)是一组命令的集合。MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。 事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部执行，要么全不执行。 事务的应用非常普遍，比如银行汇款过程中A向B汇款，系统先从A的账户中将钱划走，然后向B的账户中增加相应的金额。这两个步骤必须属于同一个事务，要么全部执行，要么全不执行。 Redis的基本事务(basic transaction)需要用到MULTI和EXEC命令。在Redis中，被MULTI和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕后，才会处理其他客户端的命令。 Redis中执行事务的步骤：首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，最后再执行EXEC命令。MULTI命令用于开启一个事务，它总是返回OK 。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。另一方面，通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务。EXEC命令的回复是一个数组，数组中的每个元素都是执行事务中的命令所产生的回复。其中，回复元素的先后顺序和命令发送的先后顺序一致。当客户端处于事务状态时，所有传入的命令都会返回一个内容为QUEUED的状态回复status reply，这些被入队的命令将在EXEC命令被调用时执行。 从语义上来说，Redis事务在Python客户端中是由管道(pipeline)实现的：对连接对象调用pipeline()方法将创建一个事务，在一切正常的情况下，客户端会自动地调用MULTI命令包裹用户输入的多个命令。此外，为了减少Redis与客户端之间的通信往返次数，提升执行多个命令的性能，Python的Redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令都发送给Redis。 要展示事务执行的结果，最简单的方法就是将事务放到线程里面执行，下面这个交互示例展示了在没有使用事务的情况下，执行并行(parallel)自增操作的结果1234567891011121314151617&gt;&gt;&gt; import redis&gt;&gt;&gt; import threading&gt;&gt;&gt; import time&gt;&gt;&gt; r = redis.StrictRedis(host='localhost', port=6379, db=0)&gt;&gt;&gt; def notrans():... print(r.incr('notrans:'))... time.sleep(.1)... r.incr('notrans:', -1)...&gt;&gt;&gt; if 1:... for i in range(3):... threading.Thread(target=notrans).start()... time.sleep(.5)...213 上述代码启动了3个线程来执行没有被事务包裹的自增、休眠和自减操作，正因为没有使用事务，所以三个线程都可以在执行自减操作前，对notrans:计数器执行自增操作。 下面这个交互示例就展示了如何使用事务处理命令的并行执行问题 123456789101112131415&gt;&gt;&gt; def trans():... pipeline = r.pipeline()... pipeline.incr('trans:')... time.sleep(.1)... pipeline.incr('trans:', -1)... print(pipeline.execute()[0])...&gt;&gt;&gt; if 1:... for i in range(3):... threading.Thread(target=trans).start()... time.sleep(.5)...111 首先在trans函数中创建一个事务型(transactional)管道对象，然后先把针对’tans:’计数器的自增操作放入队列，等待100ms后再将针对’tans:’计数器的自减操作放入队列，最后执行被事务包裹的命令，并打印自增操作的执行结果。最终在执行结果中可以看到，尽管自增和自减操作之间有一段延迟时间，但通过使用事务，各个线程都可以在不被其他线程打断的情况下，执行各自队列里面的命令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis学习笔记(二)：Redis命令及其Python API]]></title>
      <url>%2F2017%2F03%2F27%2FRedis-2%2F</url>
      <content type="text"><![CDATA[redis-py简介安装在之前的学习笔记(一)中已经安装过redis-py，我的Python版本是3.5.21$ pip3 install redis 快速开始123456&gt;&gt;&gt; import redis&gt;&gt;&gt; r = redis.StrictRedis(host='localhost', port=6379, db=0)&gt;&gt;&gt; r.set('key', 'value')True&gt;&gt;&gt; r.get('key')b'value' API参考Redis的官方命令文档很好地解释了每个命令的详细信息。 redis-py公开了实现这些命令的两个客户端类。 第一，StrictRedis类试图遵守官方命令语法， 但是有些一些例外： SELECT: 没有实现，考虑到线程安全的原因。 DEL: 由于del是python语法关键字，所用delete来代替。 CONFIG GET|SET: 分开用 config_get or config_set来代替 MULTI/EXEC: 事务作为Pipeline类的其中一部分的实现。Pipeline默认保证了MULTI,EXEC声明。但是你可以指定transaction=False来禁用这一行为。 SUBSCRIBE/LISTEN:PubSub作为一个独立的类来实现发布订阅机制。 SCAN/SSCAN/HSCAN/ZSCAN:每个命令都对应一个等价的迭代器方法scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior。 第二，Redis类是StrictRedis的子类，提供redis-py版本向后的兼容性。 关于StrictRedis与Redis的区别：(官方推荐使用StrictRedis.) 以下几个方法在StrictRedis和Redis类中的参数顺序不同。 LREM: 在Redis类中是这样的：lrem(self, name, value, num=0)在StrictRedis类中是这样的：lrem(self, name, count, value) ZADD: 在Redis类中是这样的：zadd(‘my-key’, ‘name1’, 1.1, ‘name2’, 2.2, name3=3.3, name4=4.4)在StrictRedis中是这样的：zadd(‘my-key’, 1.1, ‘name1’, 2.2, ‘name2’, name3=3.3, name4=4.4) SETEX: 在Redis类中是这样的：setex(self, name, value, time)而在StrictRedis中是这样的：setex(self, name, time, value) 连接池 redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认情况下，每个Redis实例都会依次创建并维护一个自己的连接池。我们可以直接建立一个连接池，然后传递给Redis或StrictRedis连接命令作为参数，这样就可以实现多个Redis实例共享一个连接池，以实现客户端分片，或者对连接的管理方式进行更高精度的控制。 12&gt;&gt;&gt; pool = redis.ConnectionPool(host='localhost', port=6379, db=0)&gt;&gt;&gt; r = redis.StrictRedis(connection_pool=pool) 我们也可以创建自己的Connection子类，用于控制异步框架中的套接字行为，要使用自己的连接实例化客户端类，需要创建一个连接池，将类传递给connection_class参数。 1&gt;&gt;&gt; pool = redis.ConnectionPool(connection_class=YourConnectionClass,your_arg='...', ...) 释放连接回到连接池：可以使用Redis类的reset()方法，或者使用with上下文管理语法。 解析器：解析器控制如何解析Redis-server的响应内容，redis-py提供两种方式的解析器类支持PythonParser和HiredisParser(需要单独安装)。它优先选用HiredisParser,如果不存在，则选用PythonParser. Hiredis是redis核心团队开发的一个高性能c库，能够提高10x的解析速度。 响应回调：The client class使用一系列的callbacks来完成响应到对应python类型的映射。这些响应回调，定义在 Redis client class中的RESPONSE_CALLBACKS字典中。你可以使用set_response_callback 方法来添加自定义回调类。这个方法接受两个参数：一个命令名字，一个回调类。回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数。 线程安全性Redis客户端实例可以安全地在线程之间共享。 在内部，连接实例只在命令执行期间从连接池检索，并在执行后直接返回到池中。 命令执行过程从不修改客户端实例上的状态。 但是，有一个警告：Redis SELECT命令。 SELECT命令允许您切换连接正在使用的数据库。 该数据库保持选中，直到选择另一个或连接关闭为止。 这会创建一个问题，因为可以将连接返回到连接到不同数据库的池。 因此，redis-py不会在客户端实例上实现SELECT命令。 如果在同一应用程序中使用多个Redis数据库，则应为每个数据库创建一个单独的客户机实例（也可能是单独的连接池）。 在线程之间传递PubSub或Pipeline对象是不安全的。 Redis命令及其对应redis-py API由于Redis官方命令文档很好地解释了每个命令的详细信息，所以我这里只对最常用的Redis命令进行整理，并给出其redis-py API。 字符串下表展示了对Redis字符串执行自增和自减操作的命令及其redis-py API。 命令 用例 描述 redis-py API INCR INCR key-name 将键存储的值加1 incr(name, amount=1) DECR DECR key-name 将键存储的值减1 decr(name, amount=1) INCRBY INCRBY key-name amount 将键存储的值加整数amount incr(name, amount=1) DECRBY DECRBY key-name amount 将键存储的值减整数amount decr(name, amount=1) INCRBYFLOAT INCRBYFLOAT key-name amount 将键存储的值加浮点数amount incrbyfloat(name, amount=1.0) 在redis-py内部，使用了INCRBY和DECRBY命令来实现incr()和decr()方法，并且第二个参数amount是可选的，默认为1。 下面这个交互示例展示了Redis的INCR和DECR操作12345678910111213&gt;&gt;&gt; r.get('key')&gt;&gt;&gt; r.incr('key')1&gt;&gt;&gt; r.incr('key', 15)16&gt;&gt;&gt; r.get('key')b'16'&gt;&gt;&gt; r.decr('key', 5)11&gt;&gt;&gt; r.set('key', 13)True&gt;&gt;&gt; r.incr('key')14 当用户将一个值存储到Redis字符串中时，如果这个值可以被解释(interpet)为十进制整数或者浮点数，那么Redis会允许用户对这个字符串执行各种INCR和DECR操作。如果用户对一个不存在的键或者一个保存了空串的键执行自增或自减操作，Redis会自动将这个键的值当作是0来处理。若非上述情况，则Redis将会返回一个错误。 除了自增和自减操作，Redis还可以对字节串进行读取和写入的操作。 下表展示了Redis用来处理字符串子串和二进制位的命令及其redis-py API。 命令 用例 描述 redis-py API APPEND APPEND key-name value 将值value追加到给定键key-name当前存储的值的末尾 append(key, value) GETRANGE GETRANGE key-name start end 获取一个偏移量从start到end的子串，包含start和end getrange(key, start, end) SETRANGE SETRANGE key-name offset value 将从start开始的子串设置为给定值 setrange(name, offset, value) GETBIT GETBIT key-name offset 将字节串看作是二进制位串，并返回位串中偏移量为offset的二进制位的值 getbit(name, offset) SETBIT SETBIT key-name offset value 将字节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设为value setbit(name, offset, value) BITCOUNT BITCOUNT key-name [start end] 统计字符串被设置为1的bit数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行 bitcount(key, start=None, end=None) BITOP BITOP operation dest-key key-name [key-name …] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 bitop(operation, dest, *keys) 在执行SETRANGE或者SETBIT命令时，如果offset比当前key对应string还要长，那这个string后面就补空字节(null)以达到offset。使用GETRANGE时超出字符串末尾的数据会被认为是空字符串，而使用GETBIT时超出字符串末尾的二进制位会被视为是0。 下面这个交互示例展示了Redis的子串操作和二进制位操作123456789101112131415161718192021222324&gt;&gt;&gt; r.append('new-string-key', 'hello ')6&gt;&gt;&gt; r.append('new-string-key', 'world!')12&gt;&gt;&gt; r.substr('new-string-key', 3, 7)b'lo wo'&gt;&gt;&gt; r.getrange('new-string-key', 3, 7)b'lo wo'&gt;&gt;&gt; r.setrange('new-string-key', 0, 'H')12&gt;&gt;&gt; r.get('new-string-key')b'Hello world!'&gt;&gt;&gt; r.setrange('new-string-key', 11, ', how are you?')25&gt;&gt;&gt; r.get('new-string-key')b'Hello world, how are you?'&gt;&gt;&gt; r.setbit('another-key', 2, 1)0&gt;&gt;&gt; r.setbit('another-key', 7, 1)0&gt;&gt;&gt; r.getbit('another-key', 1)0&gt;&gt;&gt; r.get('another-key')b'!' Redis现在的GETRANGE命令是由以前的SUBSTR命令改名而来，所以现在redis-py中两者仍然都可以使用，但是最好还是使用getrange()方法来获取子串。 列表下表展示了一些之前介绍过的常用列表命令 命令 用例 描述 redis-py API RPUSH RPUSH key value [value …] 向存于key的列表的尾部插入所有指定的值 rpush(name, *values) LPUSH LPUSH key value [value …] 将所有指定的值插入到存于key的列表的头部 lpush(name, *values) RPOP RPOP key 移除并返回key对应的list的最后一个元素 rpop(name) LPOP LPOP key 移除并返回key对应的list的第一个元素 lpop(name) LINDEX LINDEX key index 返回列表索引位置的元素 lindex(name, index) LRANGE LRANGE key start stop 返回存储在key的列表里指定范围内的元素 lrange(name, start, end) LTRIM LTRIM key start stop 修剪(trim)一个已存在的list，这样list就会只包含指定范围的指定元素 ltrim(name, start, end) 下面这个交互示例展示了Redis列表的推入和弹出操作12345678910111213141516171819202122&gt;&gt;&gt; r.rpush('list-key', 'last')1&gt;&gt;&gt; r.lpush('list-key', 'first')2&gt;&gt;&gt; r.rpush('list-key', 'new last')3&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'first', b'last', b'new last']&gt;&gt;&gt; r.lpop('list-key')b'first'&gt;&gt;&gt; r.lpop('list-key')b'last'&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'new last']&gt;&gt;&gt; r.rpush('list-key', 'a', 'b', 'c')4&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'new last', b'a', b'b', b'c']&gt;&gt;&gt; r.ltrim('list-key', 2, -1)True&gt;&gt;&gt; r.lrange('list-key', 0, -1)[b'b', b'c'] 还有几个列表命令能将元素从一个列表移动到另一个列表，或者阻塞(block)执行命令的客户端直到有其他客户端给列表添加元素为止。 下表列出了这些阻塞弹出命令以及列表之间移动元素的命令 命令 用例 描述 redis-py API BLPOP BLPOP key [key …] timeout 弹出第一个非空列表的头元素，或在timeout秒内阻塞并等待可弹出的元素出现 blpop(keys, timeout=0) BRPOP BRPOP key [key …] timeout 弹出第一个非空列表的末尾元素，或在timeout秒内阻塞并等待可弹出的元素出现 brpop(keys, timeout=0) RPOPLPUSH RPOPLPUSH source destination 原子性地返回并移除存储在source的列表的最后一个元素(列表尾部元素)， 并把该元素放入存储在destination的列表的第一个元素位置(列表头部) rpoplpush(src, dst) BRPOPLPUSH BRPOPLPUSH source destination timeout BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 brpoplpush(src, dst, timeout=0) 注：原子性是指命令正在都区或者修改数据的时候，其他客户端不能读取或修改相同的数据。 下面这个交互示例展示了Redis列表的阻塞弹出命令以及元素移动命令1234567891011121314151617181920&gt;&gt;&gt; r.rpush('list', 'item1')1&gt;&gt;&gt; r.rpush('list', 'item2')2&gt;&gt;&gt; r.rpush('list2', 'item3')1&gt;&gt;&gt; r.brpoplpush('list2', 'list', 1)b'item3'&gt;&gt;&gt; r.brpoplpush('list2', 'list', 1)&gt;&gt;&gt; r.lrange('list', 0, -1)[b'item3', b'item1', b'item2']&gt;&gt;&gt; r.brpoplpush('list', 'list2', 1)b'item2'&gt;&gt;&gt; r.blpop(['list', 'list2'], 1)(b'list', b'item3')&gt;&gt;&gt; r.blpop(['list', 'list2'], 1)(b'list', b'item1')&gt;&gt;&gt; r.blpop(['list', 'list2'], 1)(b'list2', b'item2')&gt;&gt;&gt; r.blpop(['list', 'list2'], 1) 对于阻塞弹出命令和弹出并推入命令，最常见的用例就是消息传递(messaging)和任务队列(task queue)。 集合下表展示了一部分最常用的集合命令 命令 用例 描述 redis-py API SADD SADD key member [member …] 添加一个或多个指定的member元素到key集合中 sadd(name, *values) SREM SREM key member [member …] 在key集合中移除指定的元素 srem(name, *values) SISMEMBER SISMEMBER key member 返回成员member是否是存储的集合key的成员 sismember(name, value) SCARD SCARD key 返回集合包含元素的数量 scard(name) SMEMBERS SMEMBERS key 返回key集合所有的元素 smembers(name) SRANDMEMBER SRANDMEMBER key [count] 仅提供key参数,那么随机返回key集合中的一个元素，返回含有 count 个不同的元素的数组，对count分情况处理 srandmember(name, number=None) SPOP SPOP key [count] 从key对应集合中返回并删除一个或多个元素 spop(name) SMOVE SMOVE source destination member 将member从source集合移动到destination集合中 smove(src, dst, value) 下面这个交互示例展示了这些常用的集合命令12345678910111213141516&gt;&gt;&gt; r.sadd('set-key', 'a', 'b', 'c')3&gt;&gt;&gt; r.srem('set-key', 'c', 'd')1&gt;&gt;&gt; r.srem('set-key', 'c', 'd')0&gt;&gt;&gt; r.scard('set-key')2&gt;&gt;&gt; r.smembers('set-key')&#123;b'b', b'a'&#125;&gt;&gt;&gt; r.smove('set-key', 'set-key2', 'a')True&gt;&gt;&gt; r.smove('set-key', 'set-key2', 'c')False&gt;&gt;&gt; r.smembers('set-key2')&#123;b'a'&#125; 但是集合真正厉害的地方在于组合和关联多个集合，下表展示了相关的Redis命令 命令 用例 描述 redis-py API SDIFF SDIFF key [key …] 返回一个集合与给定集合的差集的元素 sdiff(keys, *args) SDIFFSTORE SDIFFSTORE destination key [key …] 类似于 SDIFF，不同之处在于该命令不返回结果集，而是将结果存放在destination集合中，如果destination已经存在, 则将其覆盖重写 sdiffstore(dest, keys, *args) SINTER SINTER key [key …] 返回指定所有的集合的成员的交集 sinter(keys, *args) SINTERSTORE SINTERSTORE destination key [key …] 与SINTER命令类似，但是它并不是直接返回结果集，而是将结果保存在 destination集合中，如果destination集合存在, 则会被重写 sinterstore(dest, keys, *args) SUNION SUNION key [key …] 返回给定的多个集合的并集中的所有成员 sunion(keys, *args) SUNIONSTORE SUNIONSTORE destination key [key …] 类似于SUNION命令，不同的是它并不返回结果集，而是将结果存储在destination集合中，如果destination已经存在，则将其覆盖. sunionstore(dest, keys, *args) 这些命令分别是并集运算、交集运算和差集运算这三个基本集合操作的“返回结果”版本和“存储结果”版本，下面这个交互示例展示了这些命令的基本使用12345678910&gt;&gt;&gt; r.sadd('skey1', 'a', 'b', 'c', 'd')4&gt;&gt;&gt; r.sadd('skey2', 'c', 'd', 'e', 'f')4&gt;&gt;&gt; r.sdiff('skey1', 'skey2')&#123;b'b', b'a'&#125;&gt;&gt;&gt; r.sinter('skey1', 'skey2')&#123;b'c', b'd'&#125;&gt;&gt;&gt; r.sunion('skey1', 'skey2')&#123;b'd', b'a', b'f', b'e', b'c', b'b'&#125; 和Python的集合相比，Redis的集合除了可以被多个客户端远程地进行访问之外，其他的语义和功能基本都是相同的。 散列首先介绍一些常用的添加和删除键值对的Redis散列命令 命令 用例 描述 redis-py API HMGET HMGET key field [field …] 返回key指定的散列中指定字段的值 hmget(name, keys, *args) HMSET HMSET key field value [field value …] 设置key指定的散列中指定字段的值，该命令将重写所有在散列中存在的字段，如果key指定的散列不存在，会创建一个新的散列并与key关联 hmset(name, mapping) HDEL HDEL key field [field …] 从key指定的散列中移除指定的域，在散列中不存在的域将被忽略，如果key指定的散列不存在，它将被认为是一个空的散列，该命令将返回0 hdel(name, *keys) HLEN HLEN key 返回key指定的散列包含的字段的数量 hlen(name) 其中，HDEL命令已经介绍过了，而HLEN以及用于一次读取或设置多个键的HMGET和HMSET则是新出现的命令。它们既可以给用户带来方便，又可以通过减少命令的调用次数以及客户端与Redis之间的通信往返次数来提升Redis的性能。 下面这个交互示例展示了这些命令的使用方法12345678&gt;&gt;&gt; r.hmset('hash-key', &#123;'k1':'v1','k2':'v2','k3':'v3'&#125;)True&gt;&gt;&gt; r.hmget('hash-key', ['k2', 'k3'])[b'v2', b'v3']&gt;&gt;&gt; r.hlen('hash-key')3&gt;&gt;&gt; r.hdel('hash-key', 'k1', 'k3')2 之前的学习笔记(一)介绍的HGET命令和HSET命令分别是HMGET和HMSET命令的单参数版本。因为HDEL已经可以同时删除多个键值对了，所以Redis没有实现HMDEL命令。 下表列出了散列的其他几个批量操作命令，以及一些和字符串操作类似的散列命令。 命令 用例 描述 redis-py API HEXISTS HEXISTS key field 检查给定键是否存在于散列中 hexists(name, key) HKEYS HKEYS key 返回散列包含的所有键 hkeys(name) HVALS HVALS key 返回散列包含的所有值 hvals(name) HGETALL HGETALL key 返回散列包含的所有键值对 hgetall(name) HINCRBY HINCRBY key field increment 将键存储的值加上整数increment hincrby(name, key, amount=1) HINCRBYFLOAT HINCRBYFLOAT key field increment 将键存储的值加上浮点数increment hincrbyfloat(name, key, amount=1.0) 下面这个交互示例展示了这些命令的使用方法12345678910&gt;&gt;&gt; r.hmset('hash-key2', &#123;'short':'hello', 'long':1000*1&#125;)True&gt;&gt;&gt; r.hkeys('hash-key2')[b'short', b'long']&gt;&gt;&gt; r.hexists('hash-key2', 'num')False&gt;&gt;&gt; r.hincrby('hash-key2', 'num')1&gt;&gt;&gt; r.hexists('hash-key2', 'num')True 在对散列进行处理时，如果键值对的值的体积非常大，那么用户可以先用HKEYS获取散列的所有键，然后只获取必要的值，这样可以有效地减少需要传输的数据量，避免服务器阻塞。 有序集合下表展示了一些常用的有序集合命令，大部分在第一章都有介绍 命令 用例 描述 redis-py API ZADD ZADD key score member [score member …] 将带有给定分值的成员添加到有序集合中 zadd(name, args, *kwargs) ZREM ZREM key member [member …] 移除给定的成员，并返回被移除成员的数量 zrem(name, *values) ZCARD ZCARD key 返回有序集合包含的成员数量 zcard(name) ZINCRBY ZINCRBY key increment member 将member成员的分值加上increment zincrby(name, value, amount=1) ZCOUNT ZCOUNT key min max 返回分值介于min和max之间的成员数量 zcount(name, min, max) ZRANK ZRANK key member 返回成员member在有序集合中的排名 zrank(name, value) ZSCORE ZSCORE key member 返回成员member的分值 zscore(name, value) ZRANGE ZRANGE key start stop [WITHSCORES] 返回排名介于start和stop之间的成员，如果给定了可选的WITHSCORES选项，那么命令会将成员的分值也一并返回 zrange(name, start, end, desc=False, withscores=False, score_cast_func=) 下面这个交互示例展示了Redis中的一些常用的有序集合命令12345678910111213141516&gt;&gt;&gt; r.zadd('zset-key', 3, 'a', 2, 'b', 1, 'c')3&gt;&gt;&gt; r.zcard('zset-key')3&gt;&gt;&gt; r.zincrby('zset-key', 'c', 3)4.0&gt;&gt;&gt; r.zscore('zset-key', 'b')2.0&gt;&gt;&gt; r.zrank('zset-key', 'c')2&gt;&gt;&gt; r.zcount('zset-key', 0, 3)2&gt;&gt;&gt; r.zrem('zset-key', 'b')1&gt;&gt;&gt; r.zrange('zset-key', 0, -1, withscores=True)[(b'a', 3.0), (b'c', 4.0)] 其中在Python客户端用StrictRedis客户端类执行ZADD命令需要先输入分值，再输入成员，这也是Redis的标准，而Redis客户端类则截然相反。 下表展示了另外一下非常有用的有序集合命令 命令 用例 描述 redis-py API ZREVRANK ZREVRANK key member 返回有序集合里成员member的排名，成员按照分值从大到小排列 zrevrank(name, value) ZREVRANGE ZREVRANGE key start stop [WITHSCORES] 返回有序集合给定排名范围内的成员，成员按照分值从大到小排列 zrevrange(name, start, end, withscores=False, score_cast_func=) ZRANGEBYSCORE ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 返回有序集合中指定分数区间内的成员 zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=) ZREVRANGEBYSCORE ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count] 返回有序集合中指定分数区间内的成员，分数由高到低排序。 zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=) ZREMRANGEBYRANK ZREMRANGEBYRANK key start stop 移除有序集key中，指定排名(rank)区间内的所有成员 zremrangebyrank(name, min, max) ZREMRANGEBYSCORE ZREMRANGEBYSCORE key min max 移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员 zremrangebyscore(name, min, max) ZINTERSTORE ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM MIN MAX] 计算给定的numkeys个有序集合的交集，并且把结果放到destination中 zinterstore(dest, keys, aggregate=None) ZUNIONSTORE ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM MIN MAX] 计算给定的numkeys个有序集合的并集，并且把结果放到destination中。 zunionstore(dest, keys, aggregate=None) 其中有几个是没有介绍过的新命令，除了使用逆序来处理有序集合之外，ZREV*命令的工作方式和相对应的非逆序命令的工作方式完全一样(逆序就是指元素按照分值从大到小地排列)。 下面这个交互示例展示了ZINTERSTORE和ZUNIONSTORE命令的用法123456789101112131415161718&gt;&gt;&gt; r.zadd('zset-1', 1, 'a', 2, 'b', 3, 'c')3&gt;&gt;&gt; r.zadd('zset-2', 4, 'b', 1, 'c', 0, 'd')3&gt;&gt;&gt; r.zinterstore('zset-i', ['zset-1', 'zset-2'])2&gt;&gt;&gt; r.zrange('zset-i', 0, -1, withscores=True)[(b'c', 4.0), (b'b', 6.0)]&gt;&gt;&gt; r.zunionstore('zset-u', ['zset-1', 'zset-2'], aggregate='min')4&gt;&gt;&gt; r.zrange('zset-u', 0, -1, withscores=True)[(b'd', 0.0), (b'a', 1.0), (b'c', 1.0), (b'b', 2.0)]&gt;&gt;&gt; r.sadd('set-1', 'a', 'd')2&gt;&gt;&gt; r.zunionstore('zset-u2', ['zset-1', 'zset-2', 'set-1'])4&gt;&gt;&gt; r.zrange('zset-u2', 0, -1, withscores=True)[(b'd', 1.0), (b'a', 2.0), (b'c', 4.0), (b'b', 6.0)] 用户可以在执行交并运算时传入不同的聚合函数，共有sum、min、max三种可选；用户还可以把集合作为输入传给ZINTERSTORE和ZUNIONSTORE，命令会将集合看作是成员分值全为1的有序集合来处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis学习笔记(一)：初识Redis]]></title>
      <url>%2F2017%2F03%2F25%2FRedis-1%2F</url>
      <content type="text"><![CDATA[Redis简介Redis是一个速度极快的非关系数据库，也就是我们所说的NoSQL数据库(non-relational database)，它可以存储键(key)与5种不同类型的值(value)之间的映射(mapping)，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展性能，并且它还提供了多种语言的API。 Redis与memcached及其他类型数据库对比Redis经常被拿来与memcached进行比较，两者都可用于存储键值映射，性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，而且Redis除了能存储普通的字符串键，还能存储其他4种数据结构，使得Redis可以用于解决更为广泛的问题，并且即可以作为主数据库使用，又可以作为其他存储系统的辅助数据库。 下表展示了Redis与memcached，MySQL以及MongoDB的特性与功能。 名称 类型 数据存储选项 查询类型 附加功能 Redis 使用内存存储的非关系数据库 字符串、列表、集合、散列表、有序集合 每种数据类型专属的命令，以及批量操作和不完全的事务支持 发布与订阅，主从复制，持久化，脚本 memcached 使用内存存储的键值缓存 键值之间的映射 创建、读取、删除、更新等命令 多线程服务器，用于提升性能 MySQL 关系数据库 每个数据库可以包含多个表，每个表可以包含多个行；可以处理多个表的视图；支持空间和第三方扩展 SELECT、INSERT、UPDATE、DELETE、函数、存储过程 支持ACID性质(需要使用InnoDB)，主从复制，主主复制 MongoDB 使用硬盘存储(on-disk)的非关系文档存储 每个数据库可以包含多个表，每个表可以包含多个无schema的BSON文档 创建、读取、更新、删除、条件查询等命令 支持map-reduce操作，主从复制，分片，空间索引 Redis安装(mac)首先下载用于安装Rudix的引导脚本，并安装Rudix12$ curl -O http://rudix.google.code.com/hg/Ports/rudix/rudix.Py$ sudo python rudix.py install rudix 然后使用命令Rudix安装Redis，若能成功启动Redis服务器则安装成功12$ sudo rudix install redis$ redis-server 最后用pip为Python安装Redis客户端库1$ sudo pip install redis Redis数据结构简介Redis可以存储键与5种不同数据结构类型之间的映射，分别是STRING(字符串)、LIST(列表)、SET(集合)、HASH(散列)、ZSET(有序集合)。有一部分命令对于这5种数据结构是通用的，如DEL、TYPE、RENAME等；但也有一部分命令只能对特定的一种或者两种结构使用。 下表从结构存储的值及读写能力对比了Redis的5种数据结构。 结构类型 结构存储的值 结构的读写能力 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数进行自增或自减操作 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表两端推入或弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或多个元素；根据值查找或移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串互不相同 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有键值对 ZSET 字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素 Redis字符串下表展示了3种简单的字符串命令： 命令 行为 GET 获取存储在给定键中的值 SET 设置存储在给定键中的值 DEL 删除存储在给定键中的值(该命令可用于所有类型) SET、GET、DEL的使用示例：12345678910$ redis-cli127.0.0.1:6379&gt; set hello worldOK127.0.0.1:6379&gt; get hello"world"127.0.0.1:6379&gt; del hello(integer) 1127.0.0.1:6379&gt; get hello(nil)127.0.0.1:6379&gt; SET命令在执行成功时返回OK，Python客户端会将这个OK转换为True；DEL命令在执行成功时将会返回被成功删除的值的数量；GET命令在尝试得到不存在的值时，将会返回一个nil，Python客户端会将这个nil转换为None。 Redis列表下表展示了6种简单的列表命令： 命令 行为 LPUSH(RPUSH) 将给定值推入列表的左端(右端) LPOP(RPOP) 从列表的左端(右端)弹出一个值，并返回被弹出的值 LINDEX 获取列表在给定位置上的单个值 LRANGE 获取列表在给定范围上的所有值 RPUSH、LRANGE、LINDEX、LPOP的使用示例12345678910111213141516171819$ redis-cli127.0.0.1:6379&gt; rpush list-key item(integer) 1127.0.0.1:6379&gt; rpush list-key item2(integer) 2127.0.0.1:6379&gt; rpush list-key item(integer) 3127.0.0.1:6379&gt; lrange list-key 0 -11) "item"2) "item2"3) "item"127.0.0.1:6379&gt; lindex list-key 1"item2"127.0.0.1:6379&gt; lpop list-key "item"127.0.0.1:6379&gt; lrange list-key 0 -11) "item2"2) "item"127.0.0.1:6379&gt; RPUSH和LPUSH命令在执行成功后会返回当前列表的长度；列表索引范围从0开始，到-1结束，可以取出列表包含的所有元素；使用LINDEX可以从列表中取出单个元素。 Redis集合Redis的集合和列表都可以存储多个字符串，它们的不同之处在于，列表可以存储多个相同的字符串，而集合则通过散列表来保证自己存储的每个字符串都是不同的(这些散列表只有键)。 下表展示了6种简单的集合命令： 命令 行为 SADD 将给定元素添加到集合 SMEMBERS 返回集合包含的所有元素 SISMEMBER 检查给定元素是否存在于集合中 SREM 如果给定的元素存在于集合中，那么移除这个元素 SADD、SMEMBERS、SISMEMBER、SREM的使用示例12345678910111213141516171819202122232425$ redis-cli127.0.0.1:6379&gt; sadd set-key item(integer) 1127.0.0.1:6379&gt; sadd set-key item2(integer) 1127.0.0.1:6379&gt; sadd set-key item3(integer) 1127.0.0.1:6379&gt; sadd set-key item(integer) 0127.0.0.1:6379&gt; smembers set-key1) "item2"2) "item3"3) "item"127.0.0.1:6379&gt; sismember set-key item4(integer) 0127.0.0.1:6379&gt; sismember set-key item(integer) 1127.0.0.1:6379&gt; srem set-key item2(integer) 1127.0.0.1:6379&gt; srem set-key item2(integer) 0127.0.0.1:6379&gt; smembers set-key1) "item3"2) "item"127.0.0.1:6379&gt; SADD命令返回1表示成功添加到集合中，返回0表示该元素已存在于集合中；SMEMBERS命令获取到的元素组成的序列将会被Python客户端转换为Python集合；Python客户端会返回一个布尔值来表示SISMEMBER命令的检查结果；SREM命令会返回被移除元素的数量。 Redis散列Redis的散列就像一个微型Redis，它可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串也可以是数值。可以将散列看做文档数据库里面的文档，还可以看做是关系数据库里面的行，因为散列、文档和行都允许用户同时访问或修改一个或多个域(field)。 下表展示了4种简单的列表命令： 命令 行为 HSET 在散列里面关联给定的键值对 HGET 获取指定散列键的值 HGETALL 获取散列包含的所有键值对 HDEL 如果给定键存在于散列里面，那么移除这个键 HSET、HGET、HGETALL、HDEL的使用示例12345678910111213141516171819202122$ redis-cli127.0.0.1:6379&gt; hset hash-key sub-key1 value1(integer) 1127.0.0.1:6379&gt; hset hash-key sub-key2 value2(integer) 1127.0.0.1:6379&gt; hset hash-key sub-key1 value1(integer) 0127.0.0.1:6379&gt; hgetall hash-key1) "sub-key1"2) "value1"3) "sub-key2"4) "value2"127.0.0.1:6379&gt; hdel hash-key sub-key2(integer) 1127.0.0.1:6379&gt; hdel hash-key sub-key2(integer) 0127.0.0.1:6379&gt; hget hash-key sub-key1"value1"127.0.0.1:6379&gt; hgetall hash-key1) "sub-key1"2) "value1"127.0.0.1:6379&gt; HSET返回一个值来表示给定的键是否已经存在于散列里面；Python客户端会把HGETALL命令获取的整个散列转换为一个Python字典；HDEL命令执行后会返回一个值来表示给定的键在移除之前是否存在于散列里面。 Redis有序集合有序集合和散列一样，都用于存储键值对：其中有序集合的每个键称为成员（member），都是独一无二的，而有序集合的每个值称为分值（score），都必须是浮点数。有序集合是Redis里面唯一既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。 下表展示了4种简单的有序集合命令： 命令 行为 ZADD 将一个带有给定分值的成员添加到有序集合里面 ZRANGE 根据元素在有序排列中所处的位置，从有序集合里获取多个元素 ZRANGEBYSCORE 获取有序集合在给定分值范围内的所有元素 ZREM 如果给定成员存在于有序集合，那么移除这个成员 ZADD、ZRANGE、ZRANGEBYSCORE、ZREM的使用示例1234567891011121314151617181920212223$ redis-cli127.0.0.1:6379&gt; zadd zset-key 728 member1(integer) 1127.0.0.1:6379&gt; zadd zset-key 982 member0(integer) 1127.0.0.1:6379&gt; zadd zset-key 982 member0(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) "member1"2) "728"3) "member0"4) "982"127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores1) "member1"2) "728"127.0.0.1:6379&gt; zrem zset-key member1(integer) 1127.0.0.1:6379&gt; zrem zset-key member1(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) "member0"2) "982"127.0.0.1:6379&gt; 在尝试向有序集合添加元素的时候，ZADD命令会返回新添加元素的数量；ZRANGE命令获取有序集合包含的所有元素，这些元素会按照分值进行排序，Python客户端会将这些分值转换成浮点数；ZRANGEBYSCORE命令也可以根据分值来获取有序集合的其中一部分元素；ZREM命令在移除有序集合元素的时候，命令会返回被移除元素的数量。]]></content>
    </entry>

    
  
  
</search>
